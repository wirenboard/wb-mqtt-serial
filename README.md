# wb-mqtt-serial

Serial device <==> MQTT bridge which follows [Wiren Board MQTT Conventions](https://github.com/wirenboard/conventions/blob/main/README.md).
It's designed to be used on [Wiren Board](https://wirenboard.com/en/) family of programmable automation controllers.

Драйвер master-slave протоколов для устройств, работающих через
последовательный порт. Драйвер предназначен для устройств [Wiren Board](https://wirenboard.com/ru) и соответствует [Конвенции Wiren Board MQTT](https://github.com/wirenboard/conventions/blob/main/README.md).

**Содержание**

- [Описание](#описание)
  - [Поддерживаемые протоколы](#поддерживаемые-протоколы)
  - [Управление драйвером](#управление-драйвером)
- [Файл конфигурации и шаблоны](#файл-конфигурации-и-шаблоны)
  - [Общая информация](#общая-информация)
  - [Шаблоны конфигурации](#шаблоны-конфигурации)
  - [Перевод названий параметров устройств](#перевод-названий-параметров-устройств)
- [Особенности работы драйвера](#особенности-работы-драйвера)
  - [Таймауты и количество неудачных циклов](#таймауты-и-количество-неудачных-циклов)
  - [Замечания для TCP или MODBUS TCP порта](#замечания-для-tcp-или-modbus-tcp-порта)
  - [Диаграмма таймаутов цикла опроса](#диаграмма-таймаутов-цикла-опроса)
  - [Объединенное чтение регистров и его авто-отключение](#объединенное-чтение-регистров-и-его-авто-отключение)
  - [Автоматическое отключение опроса регистров](#автоматическое-отключение-опроса-регистров)
  - [Поведение в случае, если отключен опрос всех каналов, кроме каналов с событиями](#поведение-в-случае-если-отключен-опрос-всех-каналов-кроме-каналов-с-событиями)
  - [Список сконфигурированных портов](#список-сконфигурированных-портов)
  - [Прямое чтение и запись в порт](#прямое-чтение-и-запись-в-порт)
  - [Чтение и запись по протоколу Modbus](#чтение-и-запись-по-протоколу-modbus)
  - [Прямая установка параметров связи устройства](#прямая-установка-параметров-связи-устройства)
  - [Поиск устройств, используя Быстрый Модбас](#поиск-устройств-используя-быстрый-модбас)
  - [Получение информации об устройстве Wiren Board](#получение-информации-об-устройстве-wiren-board)
  - [Чтение настроек устройств](#чтение-настроек-устройств)
  - [Чтение каналов и параметров устройств](#чтение-каналов-и-параметров-устройств)
  - [Запись каналов и параметров устройств](#запись-каналов-и-параметров-устройств)
  - [Управление опросом устройств](#управление-опросом-устройств)
  - [Обработка счётчиков нажатий](#обработка-счётчиков-нажатий)
- [Протоколы](#протоколы)
  - [Поддержка различных протоколов на одной шине](#поддержка-различных-протоколов-на-одной-шине)
  - [Широковещательные сообщения](#широковещательные-сообщения)
  - [IEC/ГОСТ МЭК 61107 режим C](#iec/гост-мэк-61107-режим-с)
  - [Энергомера ГОСТ МЭК 61107](#энергомера-гост-мэк-61107)
  - [Энергомера протокол CE](#энергомера-протокол-се)
  - [НЕВА МТ 32х ГОСТ МЭК 61107](#нева-мт-32х-гост-мэк-61107)
  - [DLMS/COSEM и СПОДЭС](#dlmscosem-и-сподэс)
  - [Somfy SDN](#somfy-sdn)
  - [WinDeco](#windeco)
  - [Dooya](#dooya)
  - [Dauerhaft](#dauerhaft)
  - [Меркурий 200](#меркурий-200)
  - [Меркурий 230](#меркурий-230)
  - [Таблица шаблонов device_type](#таблица-шаблонов-device_type)

## Описание

### Поддерживаемые протоколы

Драйвер wb-mqtt-serial поддерживает устройства, работающие по протоколам:

- [Modbus](https://modbus.org),
- [Uniel](http://smart.uniel.ru),
- [ИВТМ](http://www.eksis.ru/catalog/measures-of-relative-humidity-and-temperature/),
- [Меркурий 230](http://www.incotexcom.ru/m230art.htm),
- [Меркурий 200](http://www.incotexcom.ru/m200.htm),
- [Милур](http://www.milur.ru),
- [Энергомера ГОСТ МЭК 61107 и протокол СЕ](http://www.energomera.ru),
- [НЕВА МТ 32х ГОСТ МЭК 61107](https://www.meters.taipit.ru),
- [DLMS/COSEM](https://www.dlms.com), СПОДЭС (ГОСТ Р 58940-2020),
- [Somfy SDN](https://www.somfy.com),
- WinDeco,
- Dooya,
- Dauerhaft/[A-OK](https://a-okmotors.com),
- IEC/ГОСТ МЭК 61107 режим С.

### Управление драйвером

По умолчанию драйвер установлен на всех контроллерах Wiren Board и запускается автоматически при наличии непустого конфигурационного файла `/etc/wb-mqtt-serial.conf`. При первоначальной установке пакета создаётся конфигурационный файл, в котором не описано ни одного подключенного устройства. Добавьте устройства в `/etc/wb-mqtt-serial.conf`, либо воспользуйтесь онлайн-редактором настроек для начала работы.

Настройка пользователем производится через веб-интерфейс контроллера, но вы можете управлять им вручную:

- `systemctl start wb-mqtt-serial` — запустить
- `systemctl stop wb-mqtt-serial` — остановить
- `systemctl status wb-mqtt-serial` — узнать состояние

Возможен запуск демона вручную, что может быть полезно
для работы в отладочном режиме:

```
# service wb-mqtt-serial stop
# wb-mqtt-serial -c /etc/wb-mqtt-serial.conf -d
```

## Файл конфигурации и шаблоны

### Общая информация

Конфигурационный файл построен по трёхуровневой схеме:
порты (ports) -> устройства (devices) -> каналы (channels).

Конфигурация устройства device может быть задана двумя способами: вручную прописать все параметры или задать только несколько параметров.

Пример файла конфигурации с описанием параметров:

```jsonc
{
    // По DeviceType драйвер будет искать в папках с шаблонами описаний устройств
    "device_type": "DeviceType",

    // отображаемое имя устройства. Публикуется как
    // .../meta/name в MQTT
    // По умолчанию name берется из шаблона и добавляется slave_id, т.е.
    // "name" + " " + "slave_id"
    "name": "somename",

    // уникальный идентификатор устройства в MQTT.
    // каждый элемент в devices должен иметь уникальный id
    // topic'и, относящиеся в MQTT к данному устройству,
    // имеют общий префикс /devices/<идентификатор топика>/...
    // также по умолчанию берется из шаблона с добавлением slave_id:
    // "deviceID" + "_" + slave_id
    "id": "deviceID",

    // идентификатор slave
    "slave_id": slaveID,

    // включить/выключить устройство. В случае задания
    // "enabled": false опрос устройства и запись значений
    // его каналов не происходит. По умолчанию - true.
    "enabled": true,

    // если используется шаблон устройства, определения
    // каналов совмещаются. Если имя (name) в определении
    // канала устройства совпадает с именем канала в шаблоне,
    // свойства каналов из шаблона и определения устройства
    // совмещаются, при этом значения свойств из определения
    // устройства (в файле конфигурации) имеют преимущество.
    // Это можно использовать, например, для задания индивидуальных
    // интервалов опроса каналов. Если канал с таким же
    // именем, как канал в определении устройства, отсутствует
    // в шаблоне, создаётся новый канал.
    "channels": [
        {
            // имя канала. topic'и, соответствующие каналу,
            "name": "Temp 1",
            "read_period_ms": 10000
        }
    ]
}
```

Ниже приведён пример конфигурационного файла `/etc/wb-mqtt-serial.conf`

```jsonc
{
    // опция debug включает или выключает отладочную печать.
    // Опция -d командной строки wb-mqtt-serial также
    // включает отладочную печать и имеет приоритет над
    // данной опцией.
    "debug": false,

    // Задаёт интервал в секундах, в течение которого неизменяющиеся значения не будут публиковаться в MQTT.
    // По истечении интервала (но не чаще периода чтения канала) полученное значение будет опубликовано, даже если оно не изменилось.
    // Минимальный интервал - 5 секунд.
    // Если установлено отрицательное значение, то значения будут публиковаться только при изменении. Это поведение по умолчанию.
    "max_unchanged_interval": -1,

    // Задаёт максимальное число чтений регистров в секунду.
    // Не влияет на чтение регистров с заданным интервалом опроса.
    // Для снижения нагрузки на процессор рекомендуется задавать значение не более 100 для WB6 и не более 800 для WB7
    "rate_limit": 100,

    // список портов
    "ports": [
        {
            // тип порта:
            // - "serial": последовательные порты RS-485 или RS-232. Это значение выбирается по умолчанию.
            // - "tcp": serial over TCP/IP. Пакеты, формируемые для работы с последовательными портами, передаются без изменений через TCP/IP.
            // - "modbus tcp": передача по MODBUS TCP. В секции устройств с таким типом порта могут использоваться только те, что поддерживают MODBUS.
            "port_type": "serial",

            // устройство, соответствующее порту RS-485 (если выбран тип порта serial)
            "path": "/dev/ttyRS485-1",

            // IP адрес или имя хоста (если выбран тип порта TCP или MODBUS TCP)
            "address": "127.0.0.1",

            // TCP порт (если выбран тип порта TCP или MODBUS TCP)
            "port": 3000,

            // скорость порта
            "baud_rate": 9600,

            // чётность - N, O или E (по умолчанию - N)
            "parity": "N",

            // количество бит данных (по умолчанию - 8)
            "data_bits": 8,

            // количество стоп-бит
            "stop_bits": 2,

            // Максимальное время ответа устройств, подключенных к этому порту, в миллисекундах
            // Если не установлено, то принимается равным 500 мс
            // Этот параметр задан в шаблонах описания устройств, переопределять его можно только в случае некорректной работы с устройствами
            "response_timeout_ms": 100,

            // Дополнительная задержка перед каждой отправкой данных в порт в микросекундах
            // Если при работе с устройством теряются пакеты — попробуйте увеличить значение этого параметра.
            // Для соответствия протоколу Modbus RTU, установите этот параметр в значение не менее 3.5 символа при выбранной скорости — это не нужно для устройств Wiren Board, но может потребоваться для устройств сторонних производителей. Нужное значение рассчитывается по формуле: guard_interval_us = (3.5*11*10^6)/(скорость в бит/с). Например, для скорости 9600 бит/с guard_interval_us = (3.5*11*10^6)/9600 ≈ 4000 мкс.
            "guard_interval_us": 1000,

            // Таймаут соединения (только для TCP или MODBUS TCP порта).
            // Если в течение указанного времени ни по одному устройству на порту не поступило данных (а также истек "connection_max_fail_cycles"),
            // TCP соединение будет разорвано и произойдет попытка переподключения
            "connection_timeout_ms": 5000,

            // Количество неудачных циклов опроса (только для TCP или MODBUS TCP порта)
            // Если в течение указанного количества циклов опроса ни по одному устройству на порту не поступило данных (а также истек "connection_timeout_ms"),
            // TCP соединение будет разорвано и произойдет попытка переподключения
            "connection_max_fail_cycles": 2,

            // включить/выключить порт. В случае задания
            // "enabled": false опрос порта и запись значений
            // каналов в устройства на данном порту не происходит.
            // По умолчанию - true.
            "enabled": true,

            // список устройств на данном порту
            "devices": [
                {
                    // тип устройства, в системе должен быть корректный шаблон для этого типа
                    "device_type": "MSU34+TLP",

                    // отображаемое имя устройства. Публикуется как
                    // .../meta/name в MQTT
                    "name": "MSU34+TLP",

                    // уникальный идентификатор устройства в MQTT.
                    // каждое элемент в devices должен иметь уникальный id
                    // topic'и, относящиеся в MQTT к данному устройству,
                    // имеют общий префикс /devices/<идентификатор топика>/...
                    "id": "msu34tlp",

                    // идентификатор устройства.
                    // Если не указан, то используются широковещательные запросы
                    "slave_id": 2,

                    // включить/выключить устройство. В случае задания
                    // "enabled": false опрос устройства и запись значений
                    // его каналов не происходит. По умолчанию - true.
                    "enabled": true,

                    // протокол передачи устройства, если не задан, то используется "modbus"
                    "protocol": "modbus",

                    // Включить режим непрерывного чтения регистров.
                    // Поддерживается только в устройствах Wiren Board.
                    "enable_wb_continuous_read": true,

                    // максимальное количество считываемых "пустых" регистров.
                    // Драйвер в целях оптимизации может считывать регистры
                    // "пачкой". При этом, если какие-либо регистры не
                    // были включены в конфигурацию, но в целях ускорения
                    // опроса (чтобы не разрывать "пачку") их всё-таки
                    // можно считывать, можно указать значение max_reg_hole
                    // больше 0. В данный момент поддерживается только
                    // устройствами Modbus.
                    "max_reg_hole": 10,

                    // то же самое, что max_reg_hole, но для однобитовых
                    // регистров (coils и discrete inputs в Modbus). В данный
                    // момент поддерживается только устройствами Modbus.
                    "max_bit_hole": 80,

                    // Максимальное количество 16-битных регистров в одной пакетной операции чтения (в данный момент поддерживается только устройствами Modbus).
                    // Если равно нулю или превышает максимально допустимое значение, используется максимально допустимое значение (125).
                    // Если не указано, используется значение по умолчанию (1).
                    "max_read_registers": 10,

                    // Минимальное количество регистров в одной пакетной операции чтения (в данный момент поддерживается только устройствами Modbus).
                    "min_read_registers": 1,

                    // Максимальное количество 16-битных регистров в одной пакетной операции записи (в данный момент поддерживается только устройствами Modbus).
                    // Используеся для пакетной записи параметров устройств при запуске wb-mqtt-serial.
                    // Следует иметь в виду, что пакетная запись не поддерживает запись отдельных битов в регистры, такие регистры будут записываться по одному. 
                    // Если равно нулю или превышает максимально допустимое значение, используется максимально допустимое значение (123).
                    // Если не указано, используется значение по умолчанию (1).
                    // Значение может быть проигнорированно в случае, если оно меньше, чем количество 16-битных регистров в записываемом параметре.
                    "max_write_registers": 10,

                    // Максимальное время ответа устройства в миллисекундах.
                    // Если не установлено, то принимается равным 500 мс.
                    // Если значение этого параметра, установленное для порта, больше указанного здесь, используется значение порта.
                    // Этот параметр задан в шаблонах описания устройств, переопределять его можно только в случае некорректной работы с устройством.
                    "response_timeout_ms": 100,

                    // Минимально необходимая задержка между посылками в миллисекундах.
                    // Используется в некоторых протоколах для определения границ посылок.
                    // Этот параметр задан в шаблонах описания устройств, переопределять его можно только в случае некорректной работы с устройством.
                    // По умолчанию 20 мс
                    "frame_timeout_ms": 100,

                    // Принудительно использовать определения границ пакета по времени между передачей байт.
                    // В протоколе MODBUS для ускорения опроса после получения нужного числа байт в ответе, сразу шлётся следующий запрос.
                    // Включение этого параметра приведёт к тому, что сервис будет ожидать время,
                    // равное frame_timeout_ms, даже после получения полного ответа.
                    // Данные, полученные сверх ожидаемой длины ответа, будут отброшены, а частота опроса может уменьшиться.
                    // По умолчанию false
                    "force_frame_timeout": true,

                    // Дополнительная задержка перед каждой отправкой данных в порт в микросекундах.
                    // Если не установлено, то используется значение, заданное в соответствующем параметре порта.
                    "guard_interval_us": 0,

                    // (При возникновении ошибки) Интервал после последнего успешного обмена данными с устройством,
                    // по истечении которого (а также "device_max_fail_cycles") устройство будет помечено отключенным и будет опрашиваться в ограниченном режиме
                    "device_timeout_ms": 3000,

                    // Количество неудачных циклов опроса устройства
                    // Если в течение указанного количества полных циклов опроса ни по одному регистру устройства не поступило данных (а также истек "device_timeout_ms"),
                    // устройство будет помечено отключенным и будет опрашиваться в ограниченном режиме
                    "device_max_fail_cycles": 2,

                    // Время в секундах, в течение которого будут продолжаться попытки записи регистра
                    // При нуле, будет произведена только одна попытка записи регистра
                    "max_write_fail_time_s": 600,

                    // Минимальное время в миллисекундах между получением ответа от устройства и следующим запросом к нему
                    "min_request_interval": 10,

                    // пароль для доступа к устройству, массив байт
                    "password": [1, 2, 3],

                    // уровень доступа при опросе устройства,
                    // используется для обмена с счётчиками электроэнергии
                    "access_level": 1,

                    // Параметр, заданный в шаблоне устройства
                    "param1": 10,

                    // Список каналов устройства
                    "channels": [
                        {
                            // Имя канала, используется в диагностических сообщениях и, если не задан параметр id, для формирования названия MQTT topic'ов канала
                            "name": "Temp 1",

                            // Имя MQTT контрола канала. 
                            // Topic'и, соответствующие каналу, публикуются как /devices/<идентификатор устройства>/controls/<ID канала>.
                            // Если не задан, то используется значение параметра "name".
                            "id": "Temp",

                            // Включает канал в цикл опроса, по умолчанию - true
                            "enabled": true,

                            // Тип регистра.
                            // Возможные значения для Modbus:
                            //   "coil" - 1 бит, чтение/запись
                            //   "discrete" - 1 бит, только чтение
                            //   "holding" - 16 бит, чтение/запись, код функции на запись выбирается автоматически, в зависимости от размера
                            //   "input" - 16 бит, только чтение
                            //   "holding_single" - то же, что и "holding", но регистры записываются всегда по одному, кодом 06
                            //   "holding_multi" - то же, что и "holding", но регистры записываются всегда кодом 16
                            //   "press_counter" - то же, что "input", предназначен для регистров, которые обнуляются после перезагрузки устройства (0 после перезагрузки не публикуется в MQTT, публикуется следующее полученное ненулевое значение)
                            "reg_type": "input",

                            // Адрес первого регистра канала.
                            // Можно читать отдельные биты полученных регистров, для этого запишите адрес в формате:
                            //   "address":"reg:shift:width", где
                            //     reg — адрес первого регистра,
                            //     shift — смещение от младшего бита первого регистра,
                            //     width — количество считываемых битов.
                            // Например, "address":"109:1:2" — прочитать второй и третий биты регистра, расположенного по адресу 109.
                            "address": 0,

                            // Адрес певого регистра канала только для записи (задается при необходимости).
                            // Если задан, то чтение параметра производится по адресу, указанному в "address", а запись — по адресу, указанному в "write_address".
                            // При этом, если параметр "address" не указывать, то будет доступна только запись по адресу в "write_address".
                            "write_address": 10,

                            // Тип элемента управления, например: "temperature", "text", "switch"
                            "type": "temperature",

                            // Формат канала, задаётся для регистров типа "holding" и "input".
                            // Возможные значения:
                            //   "u16" - беззнаковое 16-битное целое (используется по умолчанию)
                            //   "s16" - знаковое 16-битное целое
                            //   "u8" - беззнаковое 8-битное целое
                            //   "s8" - знаковое 8-битное целое
                            //   "u32" - беззнаковое 32-битное целое (занимает 2 регистра, начиная с указанного)
                            //   "s32" - знаковое 32-битное целое (занимает 2 регистра, начиная с указанного)
                            //   "s64" - знаковое 64-битное целое (занимает 4 регистра, начиная с указанного)
                            //   "u64" - беззнаковое 64-битное целое (занимает 4 регистра, начиная с указанного)
                            //   "float" - число с плавающей точкой IEEE 754, 32 bit (занимает 2 регистра, начиная с указанного)
                            //   "double" - число с плавающей точкой двойной точности IEEE 754, 64 bit (занимает 4 регистра, начиная с указанного)
                            //   "char8" - однобайтовый символ в кодировке ASCII
                            //   "bcd8" -  8-битный BCD (двоично-десятичный код)
                            //   "bcd16" - 16-битный BCD (двоично-десятичный код)
                            //   "bcd24" - 24-битный BCD (двоично-десятичный код)
                            //   "bcd32" - 32-битный BCD (двоично-десятичный код)
                            //   "string" - строка с настраиваемым количеством символов
                            //              Для протокола Modbus строки считываются по одному символу на регистр из младшего или старшего байта, в зависимости от значения параметра "byte_order" (для "big_endian" используется младший байт, для "little_endian" - старший).
                            //              При использовании формата string обязательно указывать параметр "string_data_size".
                            //              Строка вычитывается до достижения указанного размера или пока не появится байт 0x00 или 0xFF.
                            //   "string8" - то же, что и "string", но по два символа на регистр, порядок символов в регистре зависит от значения параметра "byte_order"
                            "format": "s8",

                            // Порядок 16-битных слов для каналов, имеющих размер больше 16 бит.
                            // В данный момент не поддерживатеся для регистров типа "holding_single".
                            // Возможные значения:
                            //  "big_endian" (по умолчанию): [0xAA 0xBB] [0xCC 0xDD] => 0xAABBCCDD
                            //  "little_endian":  [0xAA 0xBB] [0xCC 0xDD] => 0xCCDDAABB
                            "word_order": "big_endian",

                            // Порядок байт в 16-битных словах.
                            // Возможные значения:
                            //  "big_endian" (по умолчанию): [0x12 0x34] => 0x1234
                            //  "little_endian":  [0x12 0x34] => 0x3412
                            "byte_order": "big_endian",

                            // Период чтения данного канала в миллисекундах.
                            // Рекомендуется использовать для каналов, данные от которых надо получать с минимальными задержками.
                            // Чтение каналов с заданным периодом имеет больший приоритет, чем чтение других каналов.
                            // Если не указан, чтение будет производиться в свободное от опроса других каналов время.
                            "read_period_ms": 10,

                            // Интервал в миллисекундах, который должен пройти между двумя последовательными чтениями канала.
                            // Учитывается, если не задан параметр "read_period_ms".
                            // Не рекомендуется к использованию, поддерживается для обратной совместимости с ранее созданными конфигурационными файлами.
                            // Вместо него рекомендуется использовать read_period_ms.
                            "read_rate_limit_ms": 10000,

                            // Значение, получаемое при последовательном чтении диапазона регистров, если устройство не поддерживает запрашиваемый регистр.
                            // Этот параметр используется некоторыми протоколами, чтобы определить доступность регистров устройства.
                            "unsupported_value": "0xFFFE",

                            // Максимальное значение регистра, используется для построения интерфейса веб-конфигуратора
                            "max": 100,

                            // Коэффициент, на который умножается значение регистра перед публикацией в MQTT
                            "scale": 0.5,

                            // Значение, которое прибавляется к значению регистра перед публикацией в MQTT
                            "offset": -12.5,

                            // Порядок, до которого будет округляться значение после всех преобразований
                            "round_to": 0.1,

                            // Включение событий быстрого Modbus, если они поддерживаются прошивкой устройства.
                            // Используйте "sporadic" для дискретных каналов — будут использоваться события вместо опроса и "semi-sporadic" для аналоговых — будут использоваться события совместно с опросом, это позволит избежать «застывания» значений аналогового канала.
                            "sporadic": true,

                            // Список возможных значений
                            "enum": [1, 2, 3],

                            // Надписи значений
                            "enum_titles": ["one", "two", "three"],

                            // Доступен ли канал для записи через MQTT
                            "readonly": true,

                            // Значение, которое будет записано в регистр, при записи единицы в on-топик в MQTT
                            "on_value": "0xFF",

                            // Значение, которое будет записано в регистр, при записи нуля в on-топик в MQTT
                            "off_value": "0xAA",

                            // Значение регистра, полученное от устройства, которое обозначает ошибку
                            "error_value": "0xAA",

                            // Количество используемых регистров для протокола Modbus. Необходимая опция, если выбран формат "string" или "string8"
                            "string_data_size": 5
                        },
                        {
                            // Ещё один канал
                            "name": "Illuminance",
                            "reg_type": "input",
                            "address": 1,
                            "type": "text"
                        },
                        {
                            "name": "Pressure",
                            "reg_type": "input",
                            "address": 2,
                            "type": "text",
                            "scale": 0.075
                        },
                        {
                            "name": "Temp 2",
                            "reg_type": "input",
                            "address": 3,
                            "type": "temperature",
                            "format": "s8"
                        }
                    ]
                },
                {
                    // ещё одно устройство на канале
                    "name": "DRB88",
                    "id": "drb88",
                    "enabled": true,
                    "slave_id": 22,

                    // секция инициализации
                    "setup": [
                        {
                            // Название регистра.
                            // Выводится в случае включённой отладочной печати.
                            "title": "Input 0 type",

                            // Адрес первого регистра для записи.
                            // Для Modbus устройств можно записывать отдельные биты указанных регистров, для этого запишите адрес в формате:
                            //   "address": "reg:shift:width", где
                            //     reg — адрес первого регистра,
                            //     shift — смещение от младшего бита первого регистра,
                            //     width — количество записываемых битов
                            // Например, "address": "109:1:2" — записать второй и третий биты регистра, расположенного по адресу 109.
                            "address": 1,

                            // Значение для записи
                            "value": "1",

                            // Тип регистра, для Modbus по умолчанию - "holding"
                            "reg_type": "holding",

                            // Формат регистра, для Modbus по умолчанию - u16
                            "format": "s8"
                        },
                        {
                            "title": "Input 0 module",
                            "address": 3,
                            "value": "3"
                        }
                    ],
                    "channels": [
                        {
                            "name": "Relay 1",
                            "reg_type": "coil",
                            "address": 0,
                            "type": "switch"
                        },
                        {
                            "name": "Relay 2",
                            "reg_type": "coil",
                            "address": 1,
                            "type": "switch"
                        },
                        // ...
                        {
                            "name": "Input 2",
                            "reg_type": "input",
                            "address": 1,
                            "type": "switch",
                            "on_value": 101
                        },
                        {
                            "name": "Input 3",
                            "reg_type": "input",
                            "address": 2,
                            "type": "switch",
                            "on_value": 101
                        },
                        // ...
                    ]
                }
            ]
        },
        {
            // ещё один порт со своим набором устройств
            "path": "/dev/ttyNSC1",
            "baud_rate": 9600,
            "parity": "N",
            "data_bits": 8,
            "stop_bits": 1,
            "enabled": true,
            "devices": [
                {
                    "name": "tM-P3R3",
                    "id": "tmp3r3",
                    "enabled": true,
                    "slave_id": 1,
                    "channels": [
                        {
                            "name": "Relay 0",
                            "reg_type": "coil",
                            "address": 0,
                            "type": "switch"
                        },
                        // ...
                    ]
                },
                // ...
            ]
        }
    ]
}
```

### Шаблоны конфигурации

Шаблоны создаются для удобства конфигурации Modbus-устройств.

Шаблон конфигурации представляет собой .json файл, который содержит информацию о регистрах и параметрах устройства.

Для примера в [файле](config.sample.json) приведены разные варианты записи параметров:

- первое устройство задано через шаблон;
- второе устройство тоже через шаблон, но параметры "name" и "id" заданы, и можно добавить конфигурацию для канала, который добавится к тем, что есть в шаблоне;
- параметры третьего устройства записаны явно;
- для четвёртого задано значение одного из параметров. Параметр описан в шаблоне.

В состав пакета изначально входят шаблоны конфигурации некоторых поддерживаемых устройств. Они хранятся на контроллере в папке `/usr/share/wb-mqtt-serial/templates`. Для хранения пользовательских шаблонов используется папка `/etc/wb-mqtt-serial.conf.d/templates`.

Для создания собственного шаблона можно скопировать существующий из папки `/usr/share/wb-mqtt-serial/templates`, изменить в нем нужные параметры, добавить необходимые регистры устройства и сохранить его в папку `/etc/wb-mqtt-serial.conf.d/templates` с новым именем.

При необходимости внести обратно несовместимые изменения в шаблон, его необходимо отметить устаревшим (добавить `"deprecated": true`) и создать его копию (при этом в `device_type` нового шаблона добавить префикс с версией `tpl1_`, `tpl2_` и т.д.).

После добавления шаблона конфигурации вы можете выбрать новое устройство из выпадающего списка в настройках serial устройств в веб-интерфейсе контроллера Wiren Board.

Пример шаблона:

```jsonc
{
    // Название типа устройства, оно указывается в поле device_type в файле настроек
    "device_type": "Device type name",

    // Группа устройств в выпадающем списке в настройках последовательного порта в веб-интерфейсе контроллера
    // Если не задано устройство будет отображаться внизу списка
    // Возможные варианты:
    // g-wb — устройства Wiren Board
    // g-wb-old — устаревшие устройства Wiren Board
    // g-adapter — адаптеры протоколов
    // g-climate-sensor — датчики климата
    // g-level — датчики уровня
    // g-dimmer — диммеры
    // g-air-conditioning — кондиционеры
    // g-climate-control — контроллеры вентиляции и климата
    // g-refrigeration — контроллеры холодильного оборудования
    // g-io — модули ввода-вывода
    // g-relay — модули реле
    // g-curtain — моторы для штор / электрокарнизы
    // g-control-panel — панели управления
    // g-water-meter — счетчики воды
    // g-heat-meter — счетчики тепла
    // g-power-meter — счетчики электроэнергии
    // g-thermostat — термостаты
    // g-motor-control — управление двигателями (преобразователи частоты)
    // g-custom — произвольные устройства

    "group": "g-wb",

    // Название типа устройства, которое будет отображаться в веб-конфигураторе.
    // Необязательный параметр. Если не указан, используется device_type.
    "title": "Device",

    // Признак того, что шаблон устарел, он не будет доступен для выбора при добавлении устройства в веб-конфигураторе
    // Также для такого шаблона будут игнорироваться возможные ошибки валидации на соответствие JSON схеме
    "deprecated": true,

    // Список сигнатур устройств, которые поддерживает шаблон
    "hw": [
        {
            // Сигнатура устройства WirenBoard
            "signature": "WBMR6C",

            // Версия прошивки, начиная с которой можно использовать данный шаблон
            // Этот параметр может отсутствовать, тогда шаблон подходит к любой версии прошивки
            "fw": "1.1.1"
        }
    ],

    "device": {
        // отображаемое имя устройства. Публикуется как
        // .../meta/name в MQTT
        "name": "New device",

        // Остальные параметры устройства, описанные выше в примере конфигурационного файла, кроме slave_id
        ...

        // Шаблон может иметь собственную секцию с настройками
        "setup": [
            {
                "title": "s1",
                "address": 20000,
                "value": "0xfff2"
            },
            ...
        ],

        // Секция с описанием параметров устройства.
        // Значение параметра можно задать в файле конфигурации или через веб-конфигуратор
        "parameters": [
            {
                // Имя параметра, которе будет использовано в конфигурационном файле
                "id": "param1",

                // Название параметра в веб-конфигураторе
                "title": "s22",

                // Адрес первого регистра (должен быть одинаковым для параметров с одинаковым значением "id").
                // Для Modbus устройств можно использовать отдельные биты указанных регистров, для этого запишите адрес в формате:
                //   "address": "reg:shift:width", где
                //     reg — адрес первого регистра,
                //     shift — смещение от младшего бита первого регистра,
                //     width — количество записываемых битов
                // Например, "address": "109:1:2" — использовать второй и третий биты регистра, расположенного по адресу 109.
                "address": 9992,

                // Адрес первого регистра параметра только для записи (задается при необходимости).
                // Если задан, то чтение параметра производится по адресу, указанному в "address", а запись — по адресу, указанному в "write_address".
                // Должен быть одинаковым для параметров с одинаковым значением "id".
                "write_address": 9995,

                // Минимальная версия прошивки устройства, поддерживающая параметр.
                // Если не задана - параметр поддеживается любой прошивкой.
                // Значение должно быть одинаковым для параметров с одинаковым значением "id".
                "fw": "1.2.3",

                // Тип регистра
                "reg_type": "input",

                // Формат регистра
                "format": "s8",

                // Список возможных значений
                "enum": [1, 2, 3],

                // Надписи в списке выбора в веб-конфигураторе
                "enum_titles": ["one", "two", "three"],

                // Значение по умолчанию в веб-конфигураторе
                "default": 2,

                // Минимально возможное значение
                "min": 1,

                // Максимально возможное значение
                "max": 3,

                // Коэффициент, на который делится значение параметра перед записью в регистр
                "scale": 2,

                // Значение, которое прибавляется к значению параметра перед записью в регистр
                "offset": 10,

                // Этот параметр должен быть обязательно задан в wb-mqtt-serial.conf
                "required": true,

                // Порядок отображения параметра в веб-конфигураторе
                "order": 1,

                // Группа, к которой относится параметр
                "group": "group1",

                // Условие, при выполнении которого, значение параметра будет записано в устройство
                // В состав условия могут входить целые числа, названия других параметров,
                // операции сравнения (>, <, >=, <=, ==, !=), логические операции (&&, ||) и функция isDefined.
                // При вычислении условия вместо имён параметров подставляются их значения из конфигурационного файла.
                // Если какой-то параметр из условия не задан в конфигурационном файле,
                // то операции сравнения (>, <, >=, <=, ==) с ним возвращают false, операция проверки неравенства (!=) - возвращает true.
                // Функция isDefined позволяет определить задан ли параметр в конфигурационном файле
                // Условие также определяет доступность параметра для редактирования в интерфейсе веб-конфигуратора
                "condition": "isDefined(param1)&&(param2==1)||(param3>5)",

                // Признак того, что значение параметра не записывается в регистры устройства и не читается из них.
                // Параметр никак не связан с устройством, поля адреса игнорируются. 
                // Может быть использовано для организации настроек в веб-конфигураторе.
                // В сочетании с полем condition в зависимости от значения будут отображены только нужные каналы и параметры.
                // Значение параметра можно менять, оно будет сохраняться в конфигурационном файле
                "readonly": true
            }
        ],

        // Список каналов
        "channels": [
            // Пример канала, описывающий данные одного регистра
            {
                "name": "Temperature",
                "reg_type": "input",
                "format": "s32",
                "address": "0x0504",
                "group": "group1",

                // Условие, при выполнении которого, канал будет доступен для опроса
                "condition": "(param2==1)||(param3==5)"
            },
            ...
        ],

        // Группы используются для удобной организации интерфейса веб-конфигуратора
        // и не влияют на структуру конфигурационного файл
        "groups": [
            // Описание группы
            {
                // Уникальное имя группы, отображается в веб-конфигураторе
                "title": "Group 1",

                // Идентификатор группы
                "id": "group1",

                // Группа вложена в другую группу
                "group": "group2",

                // Описание группы
                "description": "Group description"
            },
            ...
        ]
    }
}
```

### Перевод названий параметров устройств

Переводы используются в веб-конфигураторе для формирования интерфейса настройки устройств. Они описываются в шаблоне устройства в секции `translations`. Эта секция содержит переводы строк, которые могут встречаться в названиях параметров, отчетах об ошибках и т.д. Секция содержит набор параметров `"Язык": "Строка на английском": "Перевод"`.
Например:

```jsonc
{
    "device_type": "Example",
    "title": "Device",
    "device": {
        "name": "Example device",
        "channels": [
            {
                "name": "Temperature",
                "reg_type": "holding",
                "address": 1,
                "group": "group 1"
            }
        ],
        "parameters": [
            {
                "id": "timeout",
                "title": "Timeout",
                "address": 9992,
                "group": "group 1"
            }
        ],
        "groups": [
            {
                "title": "Group 1",
                "id": "group1",
                "order": 3
            }
        ],
        "translations": {
            "ru": {
                "Device": "Устройство",
                "Temperature": "Температура",
                "Timeout": "Задержка",
                "Group 1": "Группа 1"
            }
        }
    }
}
```

## Особенности работы драйвера

### Таймауты и количество неудачных циклов

Циклом опроса устройства считается внутренний цикл опроса драйвера внутри которого был опрошен хотя бы один из регистров данного устройства.

`connection_timeout_ms` и `connection_max_fail_cycles` - указываются для порта типа TCP или MODBUS TCP. Необходимы для автоматического восстановления соединения. Если в течение `connection_timeout_ms` и более чем `connection_max_fail_cycles` подряд циклов опроса все устройства были отключены, соединение сбрасывается и происходит попытка переподключения. Можно использовать только один тип таймаута, для этого нужно выставить значение 0 другому типу таймаута (например, чтобы осуществлять обнаружение разрыва соединения только по времени, нужно выставить "`connection_max_fail_cycles`": 0). При большом количестве устройств на порту, длительность цикла опроса устройств может сильно варьироваться в зависимости от числа отвечающих устройств, т.к. они вносят дополнительные задержки на ожидание ответа, поэтому если нужно обозначить минимальное количество циклов опроса до отключения вне зависимости от числа устройств, можно использовать вариант `connection_max_fail_cycles`. При использовании только `connection_timeout_ms`, на количество попыток обращения к порту будут влиять другие временные настройки, такие как `poll_interval`, `guard_interval`, `response_timeout` и при их изменении возможно придется подстраивать значение connection_timeout_ms. Если же нужно исключить срабатывание таймаута на каких-то кратковременных случайных ошибках, которые не стоит считать обрывом связи, то нужно использовать `connection_timeout_ms`. При использовании параметров вместе, таймаут сработает только когда выполнятся оба условия, т.е. пройдет нужное время и количество циклов.

`device_timeout_ms` и `device_max_fail_cycles` - указываются для устройства. По семантике аналогичен `connection_timeout_ms` и `connection_max_fail_cycles`, но только для устройства. Нужен для выявления отключения устройства для повторной отправки setup - секции при переподключении. Если в течение `device_timeout_ms` и более чем `device_max_fail_cycles` подряд циклов ни один из опрошенных регистров не был успешно прочитан, то устройство будет помечено как отсоединенное и будет опрашиваться в ограниченном режиме, т.е. при наличии у устройства setup - секции, драйвер будет пытаться записать ее, а в противном случае, будет пытаться опросить устройство. Если первое обращение к устройству в ограниченном режиме закончилось ошибкой, драйвер считает что устройство все еще отключено и больше не опрашивает его в этом цикле. Это позволяет тратить меньше времени на отключенные устройства. Первый успешный запрос к устройству будет расценен как переподключение устройства.

#### Значения по умолчанию
|Параметр                   | Значение  |
|:--------------------------|----------:|
|device_timeout_ms          | 3000      |
|device_max_fail_cycles     | 2         |
|connection_timeout_ms      | 5000      |
|connection_max_fail_cycles | 2         |

#### Замечания для TCP или MODBUS TCP порта

При использовании TCP мостов, драйвер не видит разницы между двумя ситуациями:

- физически отключены все устройства от моста
- разорвано TCP соединение с мостом

так как в обоих случаях никаких данных драйвер не получает. Поэтому, в этом случае, connection_timeout для порта и device_timeout для устройств истекают одновременно.

Это влечет за собой периодический сброс TCP соединения и переподключение к мосту в ситуации когда физически отключены все устройства от моста, хотя с самим TCP соединением проблем нет.

В ситуации когда хотя бы одно из опрашиваемых устройств подключено к мосту без проблем с TCP соединением, TCP подключение не будет сбрасываться, а таймаут будет отсчитываться только для отключенных устройств.

### Диаграмма таймаутов цикла опроса

![Диаграмма таймаутов цикла опроса](doc/timeouts.svg)

### Объединенное чтение регистров и его авто-отключение

Для ускорения опроса регистров устройств, драйвер объединяет чтение соседних регистров в один запрос (см. `max_reg_hole`, `max_bit_hole`), однако, считывание т.н. "пустых" регистров может привести к ошибкам на некоторых устройствах. Как только драйвер получает от устройства ошибку при считывании множества регистров, среди которых есть пустые, которая могла быть вызвана чтением пустых регистров (для Modbus: `ILLEGAL_DATA_ADDRESS`, `ILLEGAL_DATA_VALUE`), драйвер перестает объединённо считывать эти регистры.
Устройства Wiren Board поддерживают [режим сплошного чтения регистров](https://wirenboard.com/wiki/Modbus#%D0%A0%D0%B5%D0%B6%D0%B8%D0%BC_%D1%81%D0%BF%D0%BB%D0%BE%D1%88%D0%BD%D0%BE%D0%B3%D0%BE_%D1%87%D1%82%D0%B5%D0%BD%D0%B8%D1%8F_%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%BE%D0%B2). Для его активации надо установить параметр `enable_wb_continuous_read` в шаблоне или настройках устройства.

### Автоматическое отключение опроса регистров

Опрос регистров может быть автоматически отключен по одной из следующих причин:
- Modbus-исключение `ILLEGAL_FUNCTION`, `ILLEGAL_DATA_ADDRESS` или `ILLEGAL_DATA_VALUE` (кроме случая, описанного [здесь](#объединенное-чтение-регистров-и-его-авто-отключение))
- считанное значение совпадает со значением параметра `unsupported_value` в настройках канала
- канал использует события быстрого Modbus (`"sporadic": true` в настройках канала)

### Поведение в случае, если отключен опрос всех каналов, кроме каналов с событиями

В случае, если отключен опрос всех каналов, кроме каналов с событиями (`"sporadic": true`), один из каналов с событиями автоматически добавляется в цикл опроса. Это необходимо для того, чтобы отслеживать доступность устройства и своевременно гененировать событие `.../meta/error` в MQTT, если связь с устройством потеряна. Период опроса этого канала устанавливаеится равным значению параметра `read_period_ms` в настройках канала. Если параметр `read_period_ms` не настроен, используется значение по умолчанию (500 мс).

### Список сконфигурированных портов

Список портов можно получить, выполнив MQTT RPC запрос `wb-mqtt-serial/ports/Load`. Он возвращает JSON массив следующего вида:

```jsonc
[
   {
       "baud_rate": 9600,
       "data_bits": 8,
       "parity": "N",
       "path": "/dev/ttyRS485-2",
       "stop_bits": 1
   },
   {
       "address": "127.0.0.1",
       "port": 2000
   },
   ...
]
```

### Прямое чтение и запись в порт

Существует возможность выполнить запись и чтение из порта посредством MQTT RPC запроса. Выполнение запроса встраивается в цикл опроса устройств таким образом, что запрос выполнится с высоким приоритетом сразу после окончания текущего цикла опроса.
Для упрощенного использования данного функционала написана [Python-библиотека](https://github.com/wirenboard/python-mqtt-rpc/). Также по [ссылке](https://github.com/wirenboard/modbus-utils-rpc) доступна утилита для работы с modbus-устройствами при помощи RPC-функционала wb-mqtt-serial.
Для выполнения запроса необходимо отправить в топик `wb-mqtt-serial/port/Load/client_id`, где `client_id` - произвольное имя клиента, посылающего запрос, сообщение типа JSON со следующими параметрами:

#### Параметры

|Параметр          |Тип          |Значение по умолчанию |Описание |
|------------------|-------------|----------------------|---------|
|`msg`             |обязательный |                      |текстовое сообщение для отправки в порт
|`response_size`   |обязательный |                      |количество байт, которое нужно прочитать из порта
|`format`          |опциональный |`STR`                 |при указании значения `STR` содержимое параметра `msg` интерпретируется как строка и передается в порт как есть. При указании значения `HEX` содержимое `msg` интерпретируется как шестнадцатеричная строка и перед отправкой в порт преобразуется в массив байт
|`response_timeout`|опциональный |500 ms                |таймаут чтения первого байта в миллисекундах. Значение сравнивается с параметром `response_timeout_ms` соответствующего порта в настройках wb-mqtt-serial и используется максимальное
|`frame_timeout`   |опциональный |20 ms                 |таймаут чтения каждого последующего байта в миллисекундах
|`total_timeout`   |опциональный |10000 ms              |таймаут выполнения RPC-запроса в миллисекундах

##### Обязательные параметры запроса в последовательный порт
|Параметр   |Описание |
|-----------|---------|
|`path`     |путь к последовательному порту, в который будет отправлено сообщение
|`baud_rate`|скорость порта
|`parity`   |чётность - N, O или E
|`data_bits`|количество бит данных
|`stop_bits`|количество стоп-бит

##### Обязательные параметры запроса в TCP порт
|Параметр |Описание |
|---------|---------|
|`ip`     |IP-адрес или имя хоста клиента, которому будет отправлено сообщение
|`port`   |номер порта на указанном адресе клиента

В качестве ответа в топике `wb-mqtt-serial/port/Load/client_id/reply` будет опубликовано сообщение типа JSON со следующими параметрами:

|Параметр | Описание|
|---------|---------|
|`result`|В случае неуспешного выполнения запроса содержит `null`. В случае успешного выполнения содержит в себе единственное поле `response`. В случае, если при запросе в поле `format` было указано `STR`, значение поля представляет собой набор символов, полученных из порта, и передается запрашивающей стороне как есть. В случае значения `HEX` содержимое поля представляет собой шестнадцатеричную строку
|`id`| Порядковый номер запроса|
|`error`|В случае успешного выполнения запроса содержит значение `null`. В ином случае содержит параметры, приведенные в таблице ниже

|Параметр|Описание|
|--------|--------|
|`message`|Строка с кратким описанием ошибки|
|`code`| Код ошибки. Возможные коды ошибок приведены в таблице ниже|
|`data`| Строка с подробным описанием места и условий возникновения ошибки|

|Код ошибки|Описание|
|----------|--------|
|`-32700`|Ошибка разбора JSON запроса|
|`-32000`|Ошибка выполнения запроса|
|`-32600`|Таймаут выполнения запроса|

Примеры выполнения запросов:

1. Успешное выполнение запроса:
   ```
   RPC Client -> {"params": {"total_timeout": 10000, "response_size": 8, "format": "HEX", "path": "/dev/ttyRS485-2", "baud_rate": 9600, "parity": "N", "data_bits": 8, "stop_bits": 2, "msg": "0A03008000018499"}, "id": 1}
   RPC Client <- {"error":null,"id":1,"result":{"response":"1605000aff00af1f"}}
   ```

2. Ошибка разбора JSON запроса
   ```
   RPC Client -> {"params""path": "/dev/ttyRS485-34534", "response_size": 8, "total_timeout": 10000, "msg": "1605000aff00af1f", "format": "HEX"}, "id": 1}
   RPC Client <-{"error":{"code":-32700,"message":"Parse error"},"id":null}
   ```

3. Ошибка выполнения запроса (ошибка ввода-вывода)
   ```
   RPC Client -> {"params": {"total_timeout": 10000, "response_size": 8, "format": "HEX", "path": "/dev/ttyRS485-2", "baud_rate": 9600, "parity": "N", "data_bits": 8, "stop_bits": 2, "msg": "0A03008000018499"}, "id": 1}
   RPC Client <- {"error":{"code":-32000,"data":"Port IO error: request timed out","message":"Server error"},"id":1,"result":null}
   ```

4. Ошибка выполнения запроса (запрос в несуществующий порт)
   ```
   RPC Client -> {"params": {"total_timeout": 10000, "response_size": 8, "format": "HEX", "path": "/dev/ttyRS485-31337", "baud_rate": 9600, "parity": "N", "data_bits": 8, "stop_bits": 2, "msg": "0A03008000018499"}, "id": 1}
   RPC Client -> {"error":{"code":-32000,"data":"Requested port doesn't exist","message":"Server error"},"id":1,"result":null}
   ```

5. Таймаут выполнения запроса (слишком малое значение таймаута)
   ```
   RPC Client -> {"params": {"response_size": 8, "format": "HEX", "path": "/dev/ttyRS485-2", "baud_rate": 9600, "parity": "N", "data_bits": 8, "stop_bits": 2, "msg": "0A03008000018499", "total_timeout": 10}, "id": 1}
   RPC Client <- {"error":{"code":-32600,"data":"Request handler is not responding @ src/rpc_handler.cpp:179","message":"Request timeout"},"id":1,"result":null}
   ```

### Чтение и запись по протоколу Modbus

Существует возможность выполнить запись и чтение регистров произвольного устройства по протоколу Modbus посредством MQTT RPC запроса. Выполнение запроса встраивается в цикл опроса устройств таким образом, что запрос выполнится с высоким приоритетом сразу после окончания текущего цикла опроса.
Для упрощенного использования данного функционала написана [Python-библиотека](https://github.com/wirenboard/python-mqtt-rpc/). Также по [ссылке](https://github.com/wirenboard/modbus-utils-rpc) доступна утилита для работы с modbus-устройствами при помощи RPC-функционала wb-mqtt-serial.
Для выполнения запроса необходимо отправить в топик `wb-mqtt-serial/port/Load/client_id`, где `client_id` - произвольное имя клиента, посылающего запрос, сообщение типа JSON со следующими параметрами:

#### Параметры

|Параметр          |Тип          |Значение по умолчанию |Описание |
|------------------|-------------|----------------------|---------|
|`protocol`        |обязательный |`modbus`, `modbus-tcp`|протокол. При указании значения `modbus` совместно с `ip` и `port` в сокет отправляется Modbus RTU сообщение, что используется при работе через прозрачные шлюзы Modbus RTU-over-TCP. Для работы по Modbus TCP укажите `modbus-tcp`.
|`slave_id`        |обязательный |                      |адрес устройства
|`function`        |обязательный |                      |код Modbus-команды
|`address`         |обязательный |                      |адрес первого Modbus-регистра
|`count`           |опциональный | 1                    |число Modbus-регистров
|`write_address`   |опциональный |                      |адрес первого Modbus-регистра для записи, в случае использования функции `23` (для других функций записи необходимо использовать параметр `address`)
|`write_count`     |опциональный | 1                    |число Modbus-регистров для записи, в случае использования функции `23` (для других функций записи необходимо использовать параметр `count`)
|`msg`             |опциональный |                      |данные Modbus-запроса, если необходимо
|`format`          |опциональный |`STR`                 |при указании значения `STR` содержимое параметра `msg` интерпретируется как строка и передается в порт как есть. При указании значения `HEX` содержимое `msg` интерпретируется как шестнадцатеричная строка и перед отправкой в порт преобразуется в массив байт
|`response_timeout`|опциональный |500 ms                |таймаут чтения первого байта в миллисекундах. Значение сравнивается с параметром `response_timeout_ms` соответствующего порта в настройках wb-mqtt-serial и используется максимальное
|`frame_timeout`   |опциональный |20 ms                 |таймаут чтения каждого последующего байта в миллисекундах
|`total_timeout`   |опциональный |10000 ms              |таймаут выполнения RPC-запроса в миллисекундах

##### Обязательные параметры запроса в последовательный порт
|Параметр   |Описание |
|-----------|---------|
|`path`     |путь к последовательному порту, в который будет отправлено сообщение
|`baud_rate`|скорость порта
|`parity`   |чётность - N, O или E
|`data_bits`|количество бит данных
|`stop_bits`|количество стоп-бит

##### Обязательные параметры запроса в TCP порт
|Параметр |Описание |
|---------|---------|
|`ip`     |IP-адрес или имя хоста клиента, которому будет отправлено сообщение
|`port`   |номер порта на указанном адресе клиента

В качестве ответа в топике `wb-mqtt-serial/port/Load/client_id/reply` будет опубликовано сообщение типа JSON со следующими параметрами:

|Параметр | Описание|
|---------|---------|
|`result`|В случае неуспешного выполнения запроса содержит `null`. В случае успешного выполнения содержит в себе поле `response` или `exception`. Если при запросе в поле `format` было указано `STR`, значение поля `response` представляет собой только данные ответа, и передается запрашивающей стороне как есть. В случае значения `HEX` содержимое поля представляет собой шестнадцатеричную строку. Если устройство вернуло ответ с ошибкой, то передаётся поле `exception`, содержащее структуру из двух полей `code` и `msg`. Где `code` - код Modbus-исключения, `msg` - его текстовая расшифровка.
|`id`| Порядковый номер запроса|
|`error`|В случае успешного выполнения запроса содержит значение `null`. В ином случае содержит параметры, приведенные в таблице ниже

|Параметр|Описание|
|--------|--------|
|`message`|Строка с кратким описанием ошибки|
|`code`| Код ошибки. Возможные коды ошибок приведены в таблице ниже|
|`data`| Строка с подробным описанием места и условий возникновения ошибки|

|Код ошибки|Описание|
|----------|--------|
|`-32700`|Ошибка разбора JSON запроса|
|`-32000`|Ошибка выполнения запроса|
|`-32600`|Таймаут выполнения запроса|


### Прямая установка параметров связи устройства

Существует возможность выполнить прямую установку параметров связи Modbus-устройства Wiren Board с помощью MQTT RPC запроса. Выполнение запроса встраивается в цикл опроса устройств таким образом, что запрос выполнится с высоким приоритетом сразу после окончания текущего цикла опроса.
Для упрощенного использования данного функционала написана [Python-библиотека](https://github.com/wirenboard/python-mqtt-rpc/). Также по [ссылке](https://github.com/wirenboard/modbus-utils-rpc) доступна утилита для работы с modbus-устройствами при помощи RPC-функционала wb-mqtt-serial.
Для выполнения запроса необходимо отправить в топик `wb-mqtt-serial/port/Setup/client_id`, где `client_id` - произвольное имя клиента, посылающего запрос, сообщение типа JSON со следующими параметрами:
```json
{
    // Путь к последовательному порту, в который будет отправлено сообщение
    "path": "/dev/ttyRS485-1",

    "items":[
        {
            // Адрес устройства
            "slave_id": 111,

             // Скорость порта
            "baud_rate": 115200,

            // Чётность - N, O или E
            "parity": "N",

            // Количество бит данных
            "data_bits": 8,

            // Количество стоп-бит
            "stop_bits": 2

            // Настройки, которые будут применены к устройству
            "cfg": {
                // Скорость порта
                "baud_rate": 115200,

                // Чётность, задаётся числом
                //   N - 0,
                //   O - 1,
                //   E - 2
                "parity": 1,

                // Количество стоп-бит
                "stop_bits": 2
            }
        },
        ...
    ]
}
```
При успешном выполнении запроса возвращается ответ следующей структуры:
```json
{
    "error": null,
    "id": ID_ЗАПРОСА,
    "result": {}
}
```
Ответы с ошибками аналогичны прямому чтению и записи в порт.


### Поиск устройств, используя Быстрый Модбас

Существует возможность выполнить поиск устройств, используя Быстрый Модбас, с помощью MQTT RPC запроса. Выполнение запроса встраивается в цикл опроса устройств таким образом, что запрос выполнится с высоким приоритетом сразу после окончания текущего цикла опроса.
Для упрощенного использования данного функционала написана [Python-библиотека](https://github.com/wirenboard/python-mqtt-rpc/).
Для выполнения запроса необходимо отправить в топик `wb-mqtt-serial/port/Scan/client_id`, где `client_id` - произвольное имя клиента, посылающего запрос, сообщение типа JSON со следующими параметрами:
```json
{
    // Путь к последовательному порту, на которому будет производиться поиск
    "path": "/dev/ttyRS485-1",

    // Скорость порта
    "baud_rate": 115200,

    // Чётность - N, O или E
    "parity": "N",

    // Количество бит данных
    "data_bits": 8,

    // Количество стоп-бит
    "stop_bits": 2,

    // команда Быстрого Модбаса, которая будет использоваться при поиске
    // актуальная - 70(0x46), устаревшая - 96(0x60)
    // если не задана, то используется 70(0x46)
    "command": 70,

    // режим поиска
    // all - будет произведён поиск всех устройств на шине
    // start - начать поиск до нахождения первого устройства
    // next - искать следующее устройство, если поиск был уже начат, используя режим start
    "mode": "start"
}
```

или

```json
{
    // IP адрес или имя хоста шлюза
    "ip": "1.1.1.1",

    // Порт шлюза
    "port": 1234,

    // команда Быстрого Модбаса, которая будет использоваться при поиске
    // актуальная - 70(0x46), устаревшая - 96(0x60)
    // если не задана, то используется 70(0x46)
    "command": 70,

    // режим поиска
    // all - будет произведён поиск всех устройств на шине
    // start - начать поиск до нахождения первого устройства
    // next - искать следующее устройство, если поиск был уже начат, используя режим start
    "mode": "start",

    // При указании значения `modbus` в сокет отправляется Modbus RTU сообщение, что используется при работе через прозрачные шлюзы Modbus RTU-over-TCP.
    // Для работы по Modbus TCP укажите `modbus-tcp`.
    // Необязательный параметр. Если не указан, используется "modbus"
    "protocol": "modbus-tcp"
}
```

При успешном выполнении запроса возвращается ответ следующей структуры:
```json
{
    // список найденных устройств
    "devices": [
        {
            // серийный номер устройства
            "sn": "13453ghh",

            // название устройства
            "device_signature": "WBMR6C",

            // сигнатура прошивки
            "fw_signature": "mr6cG",

            // если устройство настроено для опроса в wb-mqtt-serial,
            // то в этом параметре передаётся тип устройства из шаблона
            "configured_device_type": "WB-MR6C",

            // список ошибок работы с конкретным устройством
            "errors": [
                {
                    "id": "com.wb.device_manager.device.read_device_signature_error",
                    "message": "Failed to read device signature."
                },
                {
                    "id": "com.wb.device_manager.device.read_fw_signature_error",
                    "message": "Failed to read FW signature."
                }
            ],

            // текущие настройки устройства
            "cfg": {
                // адрес
                "slave_id": 100,

                // скорость шины
                "baud_rate": 9600,

                // чётность
                "parity": "N",

                // число бит данных
                "data_bits": 8,

                // число стоп бит
                "stop_bits": 2
            },

            // прошивка устройства
            "fw": {
                // версия
                "version": "1.2.3",
            }
        },
        ...
    ],

    // Ошибка, возникшая в процессе сканирования
    "error": "Serial timeout error"
}
```
Ответы с ошибками аналогичны прямому чтению и записи в порт.
При возникновении ошибки в процессе сканирования, будет возвращён список уже найденных устройств и текст ошибки.

### Получение информации об устройстве Wiren Board

Существует возможность получить информацию об устройстве Wiren Board, с помощью MQTT RPC запроса. Выполнение запроса встраивается в цикл опроса устройств таким образом, что запрос выполнится с высоким приоритетом сразу после окончания текущего цикла опроса.
Присутствие устройства на шине проверяется чтением серийного номера.
Для упрощенного использования данного функционала написана [Python-библиотека](https://github.com/wirenboard/python-mqtt-rpc/).
Для выполнения запроса необходимо отправить в топик `wb-mqtt-serial/port/Probe/client_id`, где `client_id` - произвольное имя клиента, посылающего запрос, сообщение типа JSON со следующими параметрами:
```json
{
    // Путь к последовательному порту, на которому будет производиться поиск
    "path": "/dev/ttyRS485-1",

    // Скорость порта
    "baud_rate": 115200,

    // Чётность - N, O или E
    "parity": "N",

    // Количество бит данных
    "data_bits": 8,

    // Количество стоп-бит
    "stop_bits": 2,

    // Модбас адрес устройства
    "slave_id": 100
}
```

или

```json
{
    // IP адрес или имя хоста шлюза
    "ip": "1.1.1.1",

    // Порт шлюза
    "port": 1234,

    // Модбас адрес устройства
    "slave_id": 100,

    // При указании значения `modbus` в сокет отправляется Modbus RTU сообщение, что используется при работе через прозрачные шлюзы Modbus RTU-over-TCP.
    // Для работы по Modbus TCP укажите `modbus-tcp`.
    // Необязательный параметр. Если не указан, используется "modbus"
    "protocol": "modbus-tcp"
}
```

При успешном выполнении запроса возвращается ответ следующей структуры:
```json
{
    // серийный номер устройства
    "sn": "13453",

    // модель устройства
    "device_signature": "WBMR6C",

    // сигнатура прошивки
    "fw_signature": "mr6cG",

    // если устройство настроено для опроса в wb-mqtt-serial,
    // то в этом параметре передаётся тип устройства из шаблона
    "configured_device_type": "WB-MR6C",

    // список ошибок, возникших при запросе информации об устройстве
    "errors": [
        {
            "id": "com.wb.device_manager.device.read_device_signature_error",
            "message": "Failed to read device signature."
        },
        {
            "id": "com.wb.device_manager.device.read_fw_signature_error",
            "message": "Failed to read FW signature."
        }
    ],

    // текущие настройки устройства
    "cfg": {
        // адрес
        "slave_id": 100,

        // скорость шины
        "baud_rate": 115200,

        // чётность
        "parity": "N",

        // число бит данных
        "data_bits": 8,

        // число стоп бит
        "stop_bits": 2
    },

    // прошивка устройства
    "fw": {
        // версия
        "version": "1.2.3",
    }
}
```

Если устройство отсутствует на шине, возвращается пустой JSON-объект `{}`.

Ответы с ошибками аналогичны прямому чтению и записи в порт.

### Чтение настроек устройств

Актуальные настройки устройств могут быть считаны посредством MQTT RPC запроса. Выполнение запроса встраивается в цикл опроса устройств таким образом, что запрос выполнится с высоким приоритетом сразу после окончания текущего цикла опроса.

#### Запрос с указанием типа устройства и параметров порта

Для выполнения запроса необходимо отправить в топик `wb-mqtt-serial/device/LoadConfig/client_id`, где `client_id` - произвольное имя клиента, посылающего запрос, сообщение типа JSON со следующими параметрами:

|Параметр          |Тип          |Значение по умолчанию |Описание |
|------------------|-------------|----------------------|---------|
|`slave_id`        |обязательный |                      |адрес устройства
|`device_type`     |обязательный |                      |тип устройства, как указано в соответствующем шаблоне
|`group`           |опциональный |                      |название группы параметров в шаблоне, которые необходимо cчитать, если не указано - будут cчитаны все параметры
|`response_timeout`|опциональный |500 ms                |таймаут чтения первого байта в миллисекундах. Значение сравнивается с параметром `response_timeout_ms` соответствующего порта в настройках wb-mqtt-serial и используется максимальное
|`frame_timeout`   |опциональный |20 ms                 |таймаут чтения каждого последующего байта в миллисекундах
|`total_timeout`   |опциональный |10000 ms              |таймаут выполнения RPC-запроса в миллисекундах
|`modbus_mode`     |опциональный |`RTU`                 |протокол работы с Modbus устройствами при использовании TCP порта (с указанием `ip` и `port` в запросе), возможные значения: `RTU` - для работы через прозрачные шлюзы Modbus RTU-over-TCP, `TCP` - для работы по протоколу Modbus TCP.

##### Обязательные параметры запроса в последовательный порт

|Параметр   |Описание |
|-----------|---------|
|`path`     |путь к последовательному порту, в который будет отправлено сообщение
|`baud_rate`|скорость порта
|`parity`   |чётность - N, O или E
|`data_bits`|количество бит данных
|`stop_bits`|количество стоп-бит

##### Обязательные параметры запроса в TCP порт

|Параметр |Описание |
|---------|---------|
|`ip`     |IP-адрес или имя хоста клиента, которому будет отправлено сообщение
|`port`   |номер порта на указанном адресе клиента

#### Запрос с указанием идентификатора устройства 

Для выполнения запроса необходимо отправить в топик `wb-mqtt-serial/device/LoadConfig/client_id`, где `client_id` - произвольное имя клиента, посылающего запрос, сообщение типа JSON со следующими параметрами:

|Параметр          |Тип          |Описание |
|------------------|-------------|---------|
|`device_id`       |обязательный |уникальный идентификатор устройства, как в соответствующих ему MQTT топиках ("id" из шаблона + "\_" + "slave_id", например, `wb-mr6cv3_25`)
|`group`           |опциональный |название группы параметров в шаблоне, которые необходимо cчитать, если не указано - будут cчитаны все параметры

#### Ответ на запрос

В качестве ответа в топике `wb-mqtt-serial/device/LoadConfig/client_id/reply` будет опубликовано сообщение типа JSON со следующими параметрами:

|Параметр | Описание|
|---------|---------|
|`result`|JSON-объект с данными ответа, описание приведено в таблице ниже|
|`id`| Порядковый номер запроса|
|`error`|В случае успешного выполнения запроса содержит значение `null`. В ином случае содержит параметры, приведенные в таблице ниже|

##### Данные ответа

|Параметр|Описание|
|--------|--------|
|`fw`|Версия прошивки устройства (актуально только для устройств Wiren Board, для других устройств параметра в ответе не будет)|
|`model`|Модель устройства (актуально только для устройств Wiren Board, для других устройств параметра в ответе не будет)|
|`parameters`|JSON-объект c актуальными настройками устройства (может быть пустым в случае, если никакие настройки не описаны шаблоне или не были считаны, например, из-за несоответствия версии устройства и описания настроек в шаблоне)|

##### Описание ошибок

|Параметр|Описание|
|--------|--------|
|`message`|Строка с кратким описанием ошибки|
|`code`| Код ошибки. Возможные коды ошибок приведены в таблице ниже|
|`data`| Строка с подробным описанием места и условий возникновения ошибки|

|Код ошибки|Описание|
|----------|--------|
|`-32700`|Ошибка разбора JSON запроса|
|`-32000`|Ошибка выполнения запроса|
|`-32600`|Таймаут выполнения запроса|

#### Кэширование результатов опроса

В случае, если опрашиваемое устройство присутствует в конфигурационном файле `/etc/wb-mqtt-serial.conf`, результат опроса кэшируется, а при повторных запросах для ответа используются данные из кэша. Следует иметь в виду, что изменение настроек устройства посредством RPC запроса `wb-mqtt-serial/port/Load` с использованием "сырых" данных не влияет на содержимое кэша и может привести к несоответствию реальных настроек и настроек, полученных из кэша.

В случае потери связи с устройством его данные удаляются из кэша. 

### Чтение каналов и параметров устройств

Данные каналов и параметров устройств, описанных в шаблонах, могут быть считаны посредством MQTT RPC запроса. Выполнение запроса встраивается в цикл опроса устройств таким образом, что запрос выполнится с высоким приоритетом сразу после окончания текущего цикла опроса.

#### Запрос с указанием типа устройства и параметров порта

Для выполнения запроса необходимо отправить в топик `wb-mqtt-serial/device/Load/client_id`, где `client_id` - произвольное имя клиента, посылающего запрос, сообщение типа JSON со следующими параметрами:

|Параметр          |Тип          |Значение по умолчанию |Описание |
|------------------|-------------|----------------------|---------|
|`slave_id`        |обязательный |                      |адрес устройства
|`device_type`     |обязательный |                      |тип устройства, как указано в соответствующем шаблоне
|`channels`        |опциональный |                      |JSON-массив с названиями каналов, которые необходимо считать, например, `["Input 1", "Input 2", "Input 3"]`
|`parameters`      |опциональный |                      |JSON-массив с названиями параметров, которые необходимо считать, например, `["in1_mode", "in2_mode", "in3_mode"]`
|`response_timeout`|опциональный |500 ms                |таймаут чтения первого байта в миллисекундах. Значение сравнивается с параметром `response_timeout_ms` соответствующего порта в настройках wb-mqtt-serial и используется максимальное
|`frame_timeout`   |опциональный |20 ms                 |таймаут чтения каждого последующего байта в миллисекундах
|`total_timeout`   |опциональный |10000 ms              |таймаут выполнения RPC-запроса в миллисекундах
|`modbus_mode`     |опциональный |`RTU`                 |протокол работы с Modbus устройствами при использовании TCP порта (с указанием `ip` и `port` в запросе), возможные значения: `RTU` - для работы через прозрачные шлюзы Modbus RTU-over-TCP, `TCP` - для работы по протоколу Modbus TCP.

##### Обязательные параметры запроса в последовательный порт

|Параметр   |Описание |
|-----------|---------|
|`path`     |путь к последовательному порту, в который будет отправлено сообщение
|`baud_rate`|скорость порта
|`parity`   |чётность - N, O или E
|`data_bits`|количество бит данных
|`stop_bits`|количество стоп-бит

##### Обязательные параметры запроса в TCP порт

|Параметр |Описание |
|---------|---------|
|`ip`     |IP-адрес или имя хоста клиента, которому будет отправлено сообщение
|`port`   |номер порта на указанном адресе клиента

#### Запрос с указанием идентификатора устройства 

Для выполнения запроса необходимо отправить в топик `wb-mqtt-serial/device/Load/client_id`, где `client_id` - произвольное имя клиента, посылающего запрос, сообщение типа JSON со следующими параметрами:

|Параметр   |Тип          |Описание |
|-----------|-------------|---------|
|`device_id`|обязательный |уникальный идентификатор устройства, как в соответствующих ему MQTT топиках ("id" из шаблона + "\_" + "slave_id", например, `wb-mr6cv3_25`)

#### Ответ на запрос

В качестве ответа в топике `wb-mqtt-serial/device/Load/client_id/reply` будет опубликовано сообщение типа JSON со следующими параметрами:

|Параметр | Описание|
|---------|---------|
|`result`|JSON-объект с данными ответа, описание приведено в таблице ниже|
|`id`| Порядковый номер запроса|
|`error`|В случае успешного выполнения запроса содержит значение `null`. В ином случае содержит параметры, приведенные в таблице ниже|

##### Данные ответа

|Параметр|Описание|
|--------|--------|
|`channels`|JSON-объект c актуальными данными каналов, указанных в запросе|
|`parameters`|JSON-объект c актуальными данными параметров, указанных в запросе|

##### Описание ошибок

|Параметр|Описание|
|--------|--------|
|`message`|Строка с кратким описанием ошибки|
|`code`| Код ошибки. Возможные коды ошибок приведены в таблице ниже|
|`data`| Строка с подробным описанием места и условий возникновения ошибки|

|Код ошибки|Описание|
|----------|--------|
|`-32700`|Ошибка разбора JSON запроса|
|`-32000`|Ошибка выполнения запроса|
|`-32600`|Таймаут выполнения запроса|

### Запись каналов и параметров устройств

Данные каналов и параметров устройств, описанных в шаблонах, могут быть записаны посредством MQTT RPC запроса. Выполнение запроса встраивается в цикл опроса устройств таким образом, что запрос выполнится с высоким приоритетом сразу после окончания текущего цикла опроса.

#### Запрос с указанием типа устройства и параметров порта

Для выполнения запроса необходимо отправить в топик `wb-mqtt-serial/device/Set/client_id`, где `client_id` - произвольное имя клиента, посылающего запрос, сообщение типа JSON со следующими параметрами:

|Параметр          |Тип          |Значение по умолчанию |Описание |
|------------------|-------------|----------------------|---------|
|`slave_id`        |обязательный |                      |адрес устройства
|`device_type`     |обязательный |                      |тип устройства, как указано в соответствующем шаблоне
|`channels`        |опциональный |                      |JSON-объект с данными каналов, которые необходимо записать, например, `{"K1": 0, "K1": 1, "K2": 1}`
|`parameters`      |опциональный |                      |JSON-массив с данными параметров, которые необходимо записать, например, `{"in1_mode": 0, "in2_mode": 1, "in3_mode": 2}`
|`response_timeout`|опциональный |500 ms                |таймаут чтения первого байта в миллисекундах. Значение сравнивается с параметром `response_timeout_ms` соответствующего порта в настройках wb-mqtt-serial и используется максимальное
|`frame_timeout`   |опциональный |20 ms                 |таймаут чтения каждого последующего байта в миллисекундах
|`total_timeout`   |опциональный |10000 ms              |таймаут выполнения RPC-запроса в миллисекундах
|`modbus_mode`     |опциональный |`RTU`                 |протокол работы с Modbus устройствами при использовании TCP порта (с указанием `ip` и `port` в запросе), возможные значения: `RTU` - для работы через прозрачные шлюзы Modbus RTU-over-TCP, `TCP` - для работы по протоколу Modbus TCP.

##### Обязательные параметры запроса в последовательный порт

|Параметр   |Описание |
|-----------|---------|
|`path`     |путь к последовательному порту, в который будет отправлено сообщение
|`baud_rate`|скорость порта
|`parity`   |чётность - N, O или E
|`data_bits`|количество бит данных
|`stop_bits`|количество стоп-бит

##### Обязательные параметры запроса в TCP порт

|Параметр |Описание |
|---------|---------|
|`ip`     |IP-адрес или имя хоста клиента, которому будет отправлено сообщение
|`port`   |номер порта на указанном адресе клиента

#### Запрос с указанием идентификатора устройства 

Для выполнения запроса необходимо отправить в топик `wb-mqtt-serial/device/Set/client_id`, где `client_id` - произвольное имя клиента, посылающего запрос, сообщение типа JSON со следующими параметрами:

|Параметр   |Тип          |Описание |
|-----------|-------------|---------|
|`device_id`|обязательный |уникальный идентификатор устройства, как в соответствующих ему MQTT топиках ("id" из шаблона + "\_" + "slave_id", например, `wb-mr6cv3_25`)

#### Ответ на запрос

В качестве ответа в топике `wb-mqtt-serial/device/Set/client_id/reply` будет опубликовано сообщение типа JSON со следующими параметрами:

|Параметр | Описание|
|---------|---------|
|`id`| Порядковый номер запроса|
|`error`|В случае успешного выполнения запроса содержит значение `null`. В ином случае содержит параметры, приведенные в таблице ниже|

##### Описание ошибок

|Параметр|Описание|
|--------|--------|
|`message`|Строка с кратким описанием ошибки|
|`code`| Код ошибки. Возможные коды ошибок приведены в таблице ниже|
|`data`| Строка с подробным описанием места и условий возникновения ошибки|

|Код ошибки|Описание|
|----------|--------|
|`-32700`|Ошибка разбора JSON запроса|
|`-32000`|Ошибка выполнения запроса|
|`-32600`|Таймаут выполнения запроса|

### Управление опросом устройств

Опрос устройств, добавленных в конфигурацию, может быть приостановлен и возобновлен посредством MQTT RPC запроса.

#### Запрос с указанием типа устройства и параметров порта

Для выполнения запроса необходимо отправить в топик `wb-mqtt-serial/device/SetPoll/client_id`, где `client_id` - произвольное имя клиента, посылающего запрос, сообщение типа JSON со следующими параметрами:

|Параметр          |Тип          |Значение по умолчанию |Описание |
|------------------|-------------|----------------------|---------|
|`slave_id`        |обязательный |                      |адрес устройства
|`poll`            |обязательный |                      |значение `false` останавливает опрос устройства, значение `true` возобновляет опрос устройства

После остановки опрос будет автоматически возобновлен через 10 минут. Повторые запросы на остановку опроса продлевают это время (автоматическое возобновление опроса происходит через 10 минут после последнего запроса на остановку).

После возобновления опроса осуществляется повторная настройка устройства в соответствии с шаблоном (запись регистров из секции инициализации, включение непрерывного чтения и т.д.).

##### Обязательные параметры для последовательного порта

|Параметр   |Описание |
|-----------|---------|
|`path`     |путь к последовательному порту

##### Обязательные параметры для TCP порта

|Параметр |Описание |
|---------|---------|
|`ip`     |IP-адрес или имя хоста клиента
|`port`   |номер порта на указанном адресе клиента

#### Запрос с указанием идентификатора устройства 

Для выполнения запроса необходимо отправить в топик `wb-mqtt-serial/device/SetPoll/client_id`, где `client_id` - произвольное имя клиента, посылающего запрос, сообщение типа JSON со следующими параметрами:

|Параметр   |Тип          |Описание |
|-----------|-------------|---------|
|`device_id`|обязательный |уникальный идентификатор устройства, как в соответствующих ему MQTT топиках ("id" из шаблона + "\_" + "slave_id", например, `wb-mr6cv3_25`)

#### Ответ на запрос

В качестве ответа в топике `wb-mqtt-serial/device/SetPoll/client_id/reply` будет опубликовано сообщение типа JSON со следующими параметрами:

|Параметр | Описание|
|---------|---------|
|`id`| Порядковый номер запроса|
|`error`|В случае успешного выполнения запроса содержит значение `null`. В ином случае содержит параметры, приведенные в таблице ниже|

##### Описание ошибок

|Параметр|Описание|
|--------|--------|
|`message`|Строка с кратким описанием ошибки|
|`code`| Код ошибки. Возможные коды ошибок приведены в таблице ниже|
|`data`| Строка с подробным описанием места и условий возникновения ошибки|

|Код ошибки|Описание|
|----------|--------|
|`-32700`|Ошибка разбора JSON запроса|
|`-32000`|Ошибка выполнения запроса|
|`-32600`|Таймаут выполнения запроса|

### Обработка счётчиков нажатий

В Modbus устройствах Wiren Board есть регистры, которые показывают число нажатий (одиночных, двойных, длинных и т.п.). Рекомендуется использовать их вместо прямого чтения состояния входов для организации реакции на нажатия во внешних системах. Обычно это 16-битные регистры, значение которых монотонно увеличивается. При достижении максимального значения отсчёт начинается заново с 0. При перезагрузке устройства значение сбрасывается в 0.

Для описания таких регистров в шаблонах используется тип (`reg_type`) `press_counter`.

Сервис отслеживает перезагрузку устройства и не публикует 0, если он получен сразу после перезагрузки. Это сделано для того, чтобы избежать ложных срабатываний при перезагрузке устройства. Для корректной работы этой функции прошивка устройства должна поддерживать [события "Быстрого Модбаса"](https://wirenboard.com/wiki/Fast_Modbus#%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F_%D0%BD%D0%B0_%D1%88%D0%B8%D0%BD%D0%B5).

Для всех регистров сервис записывает состояния во внутреннюю базу и публикует эти сохранённые значения при старте. База находится в оперативной памяти контроллера, она сбрасывается на диск раз в минуту или при корректной остановке сервиса. Поэтому, если значения не успели записать на диск, при запуске сервиса будет опубликовано какое-то старое значение, а потом текущее, полученное чтением из регистра. Чтобы не терять информацию о нажатиях и избежать публикации неактуальных значений, при записи значений регистров с типом `press_counter` база сразу сбрасывается на диск.

## Протоколы

### Поддержка различных протоколов на одной шине

Возможно использование устройств, работающих по различным протоколам, на одном порту. При этом следует учитывать особенности конкретных протоколов.

Например, фреймы устройств Uniel начинаются с байта 0xff, устройств ИВТМ - с байта 0x24 ('$'), в случае же протоколов Modbus, Меркурий 230 и Милур первым байтом фрейма является идентификатор slave, поэтому при совмещении подобных устройств следует внимательно подходить к выбору slave id - у устройств Милур, например, slave id по умолчанию равен 0xff, что приводит к конфликту с устройствами Uniel.

Устройства Милур требуют дополнительных задержек при опросе (заданы в шаблоне) и при использовании на одной шине с другими устройствами могут снизить скорость опроса.

Некоторые устройства, поддерживающие дополнительные протоколы, могут оказаться несовместимыми с теми или иными протоколами на той же шине, например, было замечено, что устройства с поддержкой протокола A-BUS производства "Разумный дом" не могут работать на одной шине с устройствами Uniel.

Работа устройств ИВТМ на одной шине с устройствами, работающими по другим протоколам, не проверялась. Проверенная рабочая комбинация: Modbus + Milur (slave_id != 0xff) + Uniel на одной шине.

### Modbus

### Широковещательные сообщения

Протоколы `Меркурий 230`, `Энергомера ГОСТ МЭК 61107`, `НЕВА МТ 32х ГОСТ МЭК 61107`, `IEC/ГОСТ МЭК 61107 режим С` поддерживают отправку широковещательных сообщений, если не указывать идентификатор устройства или указать вместо него пустую строку. Это можно использовать, если на шине только одно устройство такого типа, и его адрес неизвестен. При этом нельзя на одном порту одновременно использовать широковещательные сообщения `Энергомера ГОСТ МЭК 61107` и `НЕВА МТ 32х ГОСТ МЭК 61107`.

### IEC/ГОСТ МЭК 61107 режим С

При любых настройках порта фактический обмен с начинается в режиме 300 7E1, в процессе опроса переключается на 9600 7E1.
Режим ГОСТ МЭК 61107 Mode C соответствует стандарту, список параметров, доступных для чтения, можно найти в руководствах конкретных счётчиков. Параметры кодируются в адресе регистра строкой, она должна содержать полный запрос, включая `(` и `)`. Например, `1.8.0()`.

### Энергомера ГОСТ МЭК 61107

При любых настройках порта фактический обмен с счётчиками происходит в режиме 9600 7E1, в соответствии с МЭК 61107.

Реализованы 2 режима обмена:

- "быстрого группового чтения" без открытия сессии (`"protocol": "energomera_iec"`);
- ГОСТ МЭК 61107 Mode C (`"protocol": "energomera_iec_mode_c"`).

Режим "быстрого группового чтения" специфичен для протокола счётчиков Энергомера и не соответствует стандарту ГОСТ МЭК 61107. Список параметров, доступных для чтения, приведён в Таблице 11 [руководства пользователя счётчиков CE301/303](http://www.energomera.ru/documentations/product/ce301_303_rp.pdf). Поддерживаются только параметры с пустым запросом и с запросом-битовой маской.

Параметры кодируются в адресе регистра как `0xAABBCC`, где `AA` - "тип" параметра, `BB` - "уточнение", `СС` - номер бита из битовой маски запроса.

Режим ГОСТ МЭК 61107 Mode C соответствует стандарту, список параметров, доступных для чтения, можно найти в руководствах конкретных счётчиков. Параметры кодируются в адресе регистра строкой, она должна содержать полный запрос, включая `(` и `)`. Например, суммарные показания энергии для счётчика Энергомера СЕ102М будут иметь адрес `ET0PE(1)`.

### Энергомера протокол СЕ

Адрес регистра кодирует команду и данные команды. Если адрес содержит нули в старших байтах, они не передаются.

| Тип регистра | Адрес                                                                               |
|:------------:|:-----------------------------------------------------------------------------------:|
| default      | ответ может содержать беззнаковое целое размером от одного до 4-х байт              |
| energy       | ответ содержит 7 байт: первые 3 - день, месяц и год, следующие 4 - значение энергии |
| date         | ответ на команду ReadDateTime (0x0120)                                              |


### НЕВА МТ 32х ГОСТ МЭК 61107

При любых настройках порта фактический обмен с счётчиками происходит в режиме 9600 7E1, в соответствии с МЭК 61107.

Реализован режим чтения параметров по OBIS-кодам ([IEC 62056-6-1:2017](https://en.wikipedia.org/wiki/IEC_62056))

OBIS-коды кодируются в адресе регистра следующим образом:

    0xCCDDEEFF

где `CC` - группа С, `DD` - группа D, `EE` - группа E, `FF` - группа F OBIS-кода.

### DLMS/COSEM и СПОДЭС

Физический адрес устройства задаётся в параметре `slave_id`. Опрашивается логическое устройство с адресом 1.
Адрес клиента задаётся в параметре `dlms_client_address`, если он не задан, используется адрес 16 (публичный клиент).
Тип аутентификации задаётся в параметре `dlms_auth`.

Коммуникационный профиль задаётся в параметре `dlms_interface`, если он не задан, используется протокол HDLC. Поддерживается адресация по логическому имени объектов.

Данные читаются по OBIS-кодам ([IEC 62056-6-1:2017](https://en.wikipedia.org/wiki/IEC_62056)). OBIS-коды записываются в адресе регистра строкой, например `0.0.96.9.0.255`. Поддерживается автоматический разбор данных от объектов с классом `register`(class_id = 3), остальные классы не поддерживаются.

Реализован анализ доступных объектов устройства и генерация шаблона. Для этого надо остановить `wb-mqtt-serial` и запустить его из командной строки с параметром `-G`. Сгенерированный шаблон будет записан в каталог `/etc/wb-mqtt-serial.conf.d/templates`.

Пример команд для генерации шаблона:

```bash
# systemctl stop wb-mqtt-serial
# wb-mqtt-serial -G print_all,/dev/ttyMOD3,9600-8-N-1,dlms_hdlc:75,32,low,12345678
# systemctl start wb-mqtt-serial
```

Подробнее об опциях параметра `-G` можно узнать во встроенной справке `wb-mqtt-serial -G help`.

### Somfy SDN

Тип мотора(`node type`) можно задать через параметр устройства `node_type`. По умолчанию используется Sonesse 30.
Для организации отправки команд можно использовать канал с типом регистра `command`.

В этом случае заголовок пакета (`MSG`) задаётся в адресе регистра. Число, записываемое в такой регистр должно содержать длину в младшем байте. Например, `0x03020103` будет означать, что в команду будет добавлено 3 байта: 0x01, 0x02, 0x03.

Для организации запроса статуса или значений настроек можно использовать канал с типом регистра `param`. В этом случае заголовок запроса (`MSG`) задаётся в адресе регистра. А заголовок ответа - в параметре `response_header`. Поддерживается возможность указать смещение и длину данных в ответе.
Для организации записи настроек надо указать в параметре `write_address` заголовок setup-пакета.

### WinDeco

Для организации отправки команд можно использовать канал с типом регистра `command`. В этом случае код команды задаётся в адресе регистра.

### Dooya

Для организации отправки команд управления можно использовать канал с типом регистра `command`.
Для команды без параметров адрес данных задаётся в адресе регистра.
Для команды с параметром адрес данных задаётся во втором байте адреса регистра, сами данные - в младшем байте.
Для организации доступа к настройкам можно использовать канал с типом регистра `param`.
Адрес данных задаётся в адресе регистра.

### Dauerhaft

Адрес шторы задается в формате: `0x<ID мотора (1 байт)><ID канала (младший байт)><ID канала (старший байт)>`.

| Тип регистра | Адрес                                                                | R/W |
|:------------:|:--------------------------------------------------------------------:|:---:|
| command      | код команды (0xdd,0xcc,0xee,0x0d,0x0e,0xaa,0xa6,0x01,0x02,0x03,0x04) | W   |
| position     | -                                                                    | RW  |
| param        | код команды (0xd9,0xd2,0xda,0xd6,0xd7,0xd8)                          | W   |
| status       | `<0xcc00,0xcaca,0xcbcb>:<shift>:<width>`                             | R   |
| zonebit      | номер бита (0-7)                                                     | RW  |

### Меркурий 200

Типы регистров:

- param8 - восьмибитное число
- param16 - 16-тибитное число
- param24 - 24-тибитное число
- param32 - 32-тибитное число

Код команды задаётся в адресе регистра, при этом младший байт задаёт смещение данных в ответе.

### Меркурий 230

Типы регистров:

- array - массив из четырёх 2-х байтных элементов, полученный в ответ на запрос с кодом 0x05
- array12 - массив из трех 2-х байтных элементов, полученный в ответ на запрос с кодом 0x05
- param - значение, полученное в ответ на запрос с кодом 0x08
- param_sign_active - значение активной мощности со знаком, полученное в ответ на запрос с кодом 0x08
- param_sign_reactive - значение реактивной мощности со знаком, полученное в ответ на запрос с кодом 0x08
- param_sign_ignore - значение мощности без знака, полученное в ответ на запрос с кодом 0x08
- param_be - значение с порядком байт big endian, полученное в ответ на запрос с кодом 0x08

Для типов `array` и `array12` адрес регистра кодирует параметры запроса следующим образом:
 - младшие 4 бита младшего байта адреса - порядковый номер элемента в массиве ответа
 - старшие 4 бита младшего байта - номер месяца
 - младшие 4 бита старшего байта - номер массива
 - старшие 4 бита старшего байта - номер тарифа

Для остальных типов старший байт адреса регистра кодирует номер параметра, младший - номер подпараметра

### Таблица шаблонов device_type

Сгруппирована по протоколам.

**Modbus-RTU**

|                          Device                         | device_type | id_prefix  | name_prefix   |
|:-------------------------------------------------------:|:-----------:|:----------:|:-------------:|
| "Разумный дом" четырёхканальный диммер светодиодов DDL4 |    DDL24    |   ddl24    |    DDL24      |
|           "Разумный дом" релейный модуль DRB88          |    DRB88    |   drb88    |    DRB88      |
|           RD DDL04R LED Strip Dimmer                    |    DDL04R   |   ddl04r   |    DDL04R     |
|      "ICP DAS" модуль управления освещением LC-103      |    LC-103   |   lc-103   |    LC-103     |
|                   "Разумный дом" MSU24                  |    MSU24    |   msu24    |    MSU24      |
|                   "Разумный дом" MSU21                  |    MSU21    |   msu21    |    MSU21      |
|                   "Разумный дом" MSU34+TLP              |    MSU34    |   msu34tlp |  MSU34+TLP    |
|                   "Разумный дом" MSU34+TLHP             | MSU34TLHP   | msu34tlhp  |  MSU34+TLHP   |
|          "ICP DAS" модуль ввода-вывода TM-P3R3          |   TM-P3R3   |  TM-P3R3   |    tmp3r3     |
|     "Kvadro" модуль подключения термометров 1-wire      |kvadro-1wire |kvadro-1wire| Kvadro 1-Wire |
|     PD561Z-9SY счётчик электроэнергии                   |    PD561Z   |  pd561z    | pd561z        |
|     SDM220 счётчик электроэнергии                       |    SDM220   |  sdm220    |  sdm220       |
|     SDM120 счётчик электроэнергии                       |    SDM120   |  sdm120    |  sdm120       |
|     WELLPRO WP8028ADAM (8DI/8DO)                        | WP8028ADAM  | wp8028adam |   WP8028ADAM  |
|  Wiren Board RGB-диммер WB-MRGB                         |   WB-MRGB   |  WB-MRGB   |   wb-mrgb     |
|  Wiren Board Релейный модуль WB-MRM2                    |   WB-MRM2   |  WB-MRM2   |   wb-mrm2     |
|  Wiren Board Релейный модуль WB-MR11                    |   WB-MR11   |  WB-MR11   |   wb-mr11     |
|  Wiren Board Релейный модуль WB-MR14                    |   WB-MR14   |  WB-MR14   |   wb-mr14     |
|  Wiren Board модуль дискретных/счётных входов WB-MCM16  |   WB-MCM16  |  WB-MCM16  |   wb-mcm16    |
|  Wiren Board Датчик WB-MS-THLS / WB-MSW-THLS            |  WB-MS-THLS | wb-ms-thls | WB-MS-THLS    |
|  Wiren Board Датчик WB-MS-THLS / WB-MSW-THLS  (fw. v.2) |  WB-MS-THLS v.2 | wb-ms-thls | WB-MS-THLS    |
|  Peacefair PZEM-016                                     |  PZEM-016   | pzem       | PZEM          |

**Милур**
|                     Device                     | device_type   | id_prefix | name_prefix      |
|:----------------------------------------------:|:-------------:|:---------:|:----------------:|
| Счётчик электроэнергии Милур-305               | milur305      | milur305  | Milur 305        |
| Счётчик электроэнергии Милур-105 (Милур-104)   | Milur 104/105 | milur105  | Milur 105        |

**Mercury 230**
|                     Device                     | device_type | id_prefix      | name_prefix      |
|:----------------------------------------------:|:-----------:|:--------------:|:----------------:|
| Счётчик электроэнергии Меркурий-230            | mercury230  | mercury230ar02 | Mercury 230AR-02 |

**Uniel**
|                     Device                     | device_type | id_prefix      | name_prefix      |
|:----------------------------------------------:|:-----------:|:--------------:|:----------------:|
| Модуль управления освещением UCH-M111RX        | UCH-M111RX  | uchm111rx      | UCH-M111RX 0808  |
| Модуль управления автоматикой UCH-M121RX       | UCH-M121RX  | uchm121rx      | UCH-M121RX 0808  |
| Диммер светодиодных ламп UCH-M141RC            | UCH-M141RC  | uchm141rc      | UCH-M141RC 0808  |


**ИВТМ**
|                     Device                     | device_type | id_prefix      | name_prefix      |
|:----------------------------------------------:|:-----------:|:--------------:|:----------------:|
| Термогигрометр ИВТМ-7 М 3                      | IVTM-7M-3   | ivtm7m3        | IVTM-7M-3        |

**Пульсар**
|                     Device                     | device_type    | id_prefix      | name_prefix           |
|:----------------------------------------------:|:--------------:|:--------------:|:---------------------:|
| Счётчик воды "Пульсар"                         | pulsar-water   | pulsar-water   |  Pulsar Water Meter   |
| Счётчик воды многоструйный "Пульсар-М"         | pulsar-m-water | pulsar-m-water |  Pulsar-M Water Meter |
| Счётчик тепла "Пульсар"                        | pulsar-heat    | pulsar-heat    |  Pulsar Heat Meter    |

**Энергомера МЭК 61107**
|                     Device                     | device_type    | id_prefix      | name_prefix           |
|:----------------------------------------------:|:--------------:|:--------------:|:---------------------:|
| Энергомера CE301 счётчик активной электрической энергии трёхфазный                         | Energomera CE301/CE303   | energomera301   |  Energomera CE301   |
| Энергомера CE303 счётчик активной и реактивной электрической энергии трёхфазный                         | Energomera CE303   | energomera303   |  Energomera CE303   |

**Энергомера протокол CE**
|                     Device                     | device_type    | id_prefix      | name_prefix           |
|:----------------------------------------------:|:--------------:|:--------------:|:---------------------:|
| Энергомера CE102-R5.1 Счетчик электроэнергии однофазный многотарифный | Energomera CE102   | energomera102   |  Energomera CE102   |

**НЕВА МТ 323/324**
|                       Device                     | device_type   | id_prefix      | name_prefix   |
|:------------------------------------------------:|:-------------:|:--------------:|:-------------:|
| НЕВА МТ 323/324 трёхфазный многотарифный счётчик | NEVA MT 32x   | neva32x        |  NEVA MT 32x  |

**DLMS/COSEM, СПОДЭС**
|                     Device                     | device_type    | id_prefix      | name_prefix           |
|:----------------------------------------------:|:--------------:|:--------------:|:---------------------:|
| Энергомера CE308 Z счетчик электроэнергии трехфазный многофункциональный | energomera_ce308_dlms   | energomera308   |  Energomera CE308   |
| Счётчик электроэнергии Меркурий 234 D          | mercury_234_dlms   | mercury234   |  Mercury 234   |

**Somfy SDN**
|                     Device                     | device_type    | id_prefix      | name_prefix           |
|:----------------------------------------------:|:--------------:|:--------------:|:---------------------:|
| Мотор управления шторами Somfy SDN             | Somfy SDN      | somfy          |  Somfy SDN            |

**WinDeco**
|                     Device                     | device_type    | id_prefix      | name_prefix           |
|:----------------------------------------------:|:--------------:|:--------------:|:---------------------:|
| Мотор управления шторами WinDeco               | WinDeco        | windeco        |  WinDeco              |

**Dooya**
|                     Device                     | device_type    | id_prefix      | name_prefix           |
|:----------------------------------------------:|:--------------:|:--------------:|:---------------------:|
| Мотор управления шторами Dooya DT82            | Dooya 82       | dooya          |  Dooya 82             |
| Мотор управления шторами Akko AM82             | Dooya 82       | dooya          |  Dooya 82             |

**Dauerhaft**
|                     Device                     | device_type    | id_prefix      | name_prefix           |
|:----------------------------------------------:|:--------------:|:--------------:|:---------------------:|
| Мотор управления шторами Dauerhaft             | Dauerhaft      | dauerhaft      |  Dauerhaft            |
