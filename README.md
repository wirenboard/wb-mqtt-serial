# wb-mqtt-serial

Serial device <==> MQTT bridge which follows [Wiren Board MQTT Conventions](https://github.com/wirenboard/conventions/blob/main/README.md).
It's designed to be used on [Wiren Board](https://wirenboard.com/en/) family of programmable automation controllers.

Драйвер master-slave протоколов для устройств, работающих через
последовательный порт. Драйвер предназначен для устройств [Wiren Board](https://wirenboard.com/ru) и соответствует [Конвенции Wiren Board MQTT](https://github.com/wirenboard/conventions/blob/main/README.md).

**Содержание**
- [Описание](#Описание)
  - [Поддерживаемые протоколы](#Поддерживаемые-протоколы)
  - [Управление драйвером](#Управление-драйвером)
- [Файл конфигурации и шаблоны](#Файл-конфигурации-и-шаблоны)
  - [Общая информация](#Общая-информация)
  - [Шаблоны конфигурации](#Шаблоны-конфигурации)
  - [Перевод названий параметров устройств](#Перевод-названий-параметров-устройств)
- [Особенности работы драйвера](#Особенности-работы-драйвера)
  - [Таймауты и количество неудачных циклов](#Таймауты-и-количество-неудачных-циклов)  
  - [Замечания для TCP или MODBUS TCP порта](#Замечания-для-TCP-или-MODBUS-TCP-порта)
  - [Диаграмма таймаутов цикла опроса](#Диаграмма-таймаутов-цикла-опроса)
  - [Объединенное чтение регистров и его авто-отключение](#Объединенное-чтение-регистров-и-его-авто-отключение)
  - [Метрики опроса устройств](#Метрики-опроса-устройств)
  - [Прямое чтение и запись в порт](#Прямое-чтение-и-запись-в-порт)
- [Протоколы](#Протоколы)
  - [Поддержка различных протоколов на одной шине](#Поддержка-различных-протоколов-на-одной-шине)
  - [Широковещательные сообщения](#Широковещательные-сообщения)
  - [Энергомера ГОСТ МЭК 61107](#Энергомера-ГОСТ-МЭК-61107)
  - [НЕВА МТ 32х ГОСТ МЭК 61107](#НЕВА-МТ-32х-ГОСТ-МЭК-61107)
  - [DLMS/COSEM и СПОДЭС](#dlmscosem-и-сподэс)
  - [Somfy SDN](#Somfy-SDN)
  - [WinDeco](#WinDeco)
  - [Dooya](#Dooya)
  - [Меркурий 200](#Меркурий-200)
  - [Таблица шаблонов device_type](#Таблица-шаблонов-device_type)

## Описание
### Поддерживаемые протоколы
Драйвер wb-mqtt-serial поддерживает устройства, работающие по протоколам:
- [Modbus](https://modbus.org),
- [Uniel](http://smart.uniel.ru),
- [ИВТМ](http://www.eksis.ru/catalog/measures-of-relative-humidity-and-temperature/),
- [Меркурий 230](http://www.incotexcom.ru/m230art.htm),
- [Меркурий 200](http://www.incotexcom.ru/m200.htm),
- [Милур](http://www.milur.ru),
- [Энергомера ГОСТ МЭК 61107](http://www.energomera.ru),
- [НЕВА МТ 32х ГОСТ МЭК 61107](https://www.meters.taipit.ru),
- [DLMS/COSEM](https://www.dlms.com), СПОДЭС (ГОСТ Р 58940-2020),
- [Somfy SDN](https://www.somfy.com),
- WinDeco,
- Dooya.

### Управление драйвером

По умолчанию драйвер установлен на всех контроллерах Wiren Board и запускается автоматически при наличии непустого конфигурационного файла `/etc/wb-mqtt-serial.conf`. При первоначальной установке пакета создаётся конфигурационный файл, в котором не описано ни одного подключенного устройства. В этом случае запуск драйвера завершается с ошибкой. Добавьте устройства в `/etc/wb-mqtt-serial.conf`, либо воспользуйтесь онлайн-редактором настроек для начала работы.

Настройка пользователем производится через веб-интерфейс контроллера, но вы можете управлять им вручную:
- `systemctl start wb-mqtt-serial` — запустить
- `systemctl stop wb-mqtt-serial` — остановить
- `systemctl status wb-mqtt-serial` — узнать состояние


Возможен запуск демона вручную, что может быть полезно
для работы в отладочном режиме:

```
# service wb-mqtt-serial stop
# wb-mqtt-serial -c /etc/wb-mqtt-serial.conf -d
```

## Файл конфигурации и шаблоны
### Общая информация
Конфигурационный файл построен по трёхуровневой схеме:
порты (ports) -> устройства (devices) -> каналы (channels).

Конфигурация устройства device может быть задана двумя способами: вручную прописать все параметры или задать только несколько параметров.

Пример файла конфигурации с описанием параметров:
```jsonc
{
    // По DeviceType драйвер будет искать в папках с шаблонами описаний устройств
    "device_type" : "DeviceType",

    // отображаемое имя устройства. Публикуется как
    // .../meta/name в MQTT
    // По умолчанию name берется из шаблона и добавляется slave_id, т.е.
    // "name" + " " + "slave_id"
    "name" : "somename",

    // уникальный идентификатор устройства в MQTT.
    // каждое элемент в devices должен иметь уникальный id
    // topic'и, относящиеся в MQTT к данному устройству,
    // имеют общий префикс /devices/<идентификатор топика>/...
    // также по умолчанию берется из шаблона с добавлением slave_id:
    // "deviceID" + "_" + slave_id
    "id" : "deviceID",

    // идентификатор slave
    "slave_id" : slaveID,

    // включить/выключить устройство. В случае задания
    // "enabled": false опрос устройства и запись значений
    // его каналов не происходит. По умолчанию - true.
    "enabled" : true,

    // если используется шаблон устройства, определения
    // каналов совмещаются. Если имя (name) в определении
    // канала устройства совпадает с именем канала в шаблоне,
    // свойства каналов из шаблона и определения устройства
    // совмещаются, при этом значения свойств из определения
    // устройства (в файле конфигурации) имеют преимущество.
    // Это можно использовать, например, для задания индивидуальных
    // интервалов опроса каналов. Если канал с таким же
    // именем, как канал в определении устройства, отсутствует
    // в шаблоне, создаётся новый канал.
    "channels": [
        {
            // имя канала. topic'и, соответствующие каналу,
            "name" : "Temp 1",
            "read_period_ms": 10000
        }
    ]
}
```

Ниже приведён пример конфигурационного файла `/etc/wb-mqtt-serial.conf`

```jsonc
{
    // опция debug включает или выключает отладочную печать.
    // Опция -d командной строки wb-mqtt-serial также
    // включает отладочную печать и имеет приоритет над
    // данной опцией.
    "debug": false,

    // Задаёт интервал в секундах, в течение которого неизменяющиеся значения не будут публиковаться в MQTT.
    // По истечении интервала полученное значение будет опубликовано, даже если оно не изменилось.
    // Минимальный интервал - 5 секунд.
    // Если установлено отрицательное значение, то значения будут публиковаться только при изменении. Это поведение по умолчанию.
    "max_unchanged_interval": -1,

    // Задаёт максимальное число чтений регистров в секунду.
    // Не влияет на чтение регистров с заданным интервалом опроса.
    // Для снижения нагрузки на процессор рекомендуется задавать значение не более 100 для WB6 и не более 800 для WB7
    "rate_limit": 100,

    // список портов
    "ports": [
        {
            // тип порта:
            // - "serial": последовательные порты RS-485 или RS-232. Это значение выбирается по умолчанию.
            // - "tcp": serial over TCP/IP. Пакеты, формируемые для работы с последовательными портами, передаются без изменений через TCP/IP.
            // - "modbus tcp": передача по MODBUS TCP. В секции устройств с таким типом порта могут использоваться только те, что поддерживают MODBUS.
            "port_type": "serial",

            // устройство, соответствующее порту RS-485 (если выбран тип порта serial)
            "path" : "/dev/ttyRS485-1",

            // IP адрес или имя хоста (если выбран тип порта TCP или MODBUS TCP)
            "address": "127.0.0.1",

            // TCP порт (если выбран тип порта TCP или MODBUS TCP)
            "port": 3000,

            // скорость порта
            "baud_rate": 9600,

            // паритет - N, O или E (по умолчанию - N)
            "parity": "N",

            // количество бит данных (по умолчанию - 8)
            "data_bits": 8,

            // количество стоп-бит
            "stop_bits": 2,

            // Максимальное время ответа устройств, подключенных к этому порту, в миллисекундах
            // Если не установлено, то принимается равным 500 мс
            // Этот параметр задан в шаблонах описания устройств, переопределять его можно только в случае некорректной работы с устройствами
            "response_timeout_ms": 100,

            // Дополнительная задержка перед каждой отправкой данных в порт в микросекундах
            // Если при работе с устройством теряются пакеты — попробуйте увеличить значение этого параметра.
            // Для соответствия протоколу Modbus RTU, установите этот параметр в значение не менее 3.5 символа при выбранной скорости — это не нужно для устройств Wiren Board, но может потребоваться для устройств сторонних производителей. Нужное значение рассчитывается по формуле: guard_interval_us = (3.5*11*106)/(скорость в бит/с). Например, для скорости 9600 бит/с guard_interval_us = (3.5*11*106)/9600 = 4000 мкс.
            "guard_interval_us": 1000,

            // Таймаут соединения (только для TCP или MODBUS TCP порта).
            // Если в течение указанного времени ни по одному устройству на порту не поступило данных (а также истек "connection_max_fail_cycles"),
            // TCP соединение будет разорвано и произойдет попытка переподключения
            "connection_timeout_ms": 5000,

            // Количество неудачных циклов опроса (только для TCP или MODBUS TCP порта)
            // Если в течение указанного количества циклов опроса ни по одному устройству на порту не поступило данных (а также истек "connection_timeout_ms"),
            // TCP соединение будет разорвано и произойдет попытка переподключения
            "connection_max_fail_cycles": 2,

            // включить/выключить порт. В случае задания
            // "enabled": false опрос порта и запись значений
            // каналов в устройства на данном порту не происходит.
            // По умолчанию - true.
            "enabled": true,

            // список устройств на данном порту
            "devices" : [
                {
                    // тип устройства, в системе должен быть корректный шаблон для этого типа
                    "device_type": "MSU34+TLP",

                    // отображаемое имя устройства. Публикуется как
                    // .../meta/name в MQTT
                    "name": "MSU34+TLP",

                    // уникальный идентификатор устройства в MQTT.
                    // каждое элемент в devices должен иметь уникальный id
                    // topic'и, относящиеся в MQTT к данному устройству,
                    // имеют общий префикс /devices/<идентификатор топика>/...
                    "id": "msu34tlp",

                    // идентификатор устройства. 
                    // Если не указан, то используются широковещательные запросы
                    "slave_id": 2,

                    // включить/выключить устройство. В случае задания
                    // "enabled": false опрос устройства и запись значений
                    // его каналов не происходит. По умолчанию - true.
                    "enabled": true,

                    // протокол передачи устройства, если не задан, то используется "modbus"
                    "protocol": "modbus",

                    // максимальное количество считываемых "пустых" регистров.
                    // Драйвер в целях оптимизации может считывать регистры
                    // "пачкой". При этом, если какие-либо регистры не
                    // были включены в конфигурацию, но в целях ускорения
                    // опроса (чтобы не разрывать "пачку") их всё-таки
                    // можно считывать, можно указать значение max_reg_hole
                    // больше 0. В данный момент поддерживается только
                    // устройствами Modbus.
                    "max_reg_hole": 10,

                    // то же самое, что max_reg_hole, но для однобитовых
                    // регистров (coils и discrete inputs в Modbus). В данный
                    // момент поддерживается только устройствами Modbus.
                    "max_bit_hole": 80,

                    // максимальное количество регистров в одной пакетной операции
                    // чтения. В данный момент поддерживается только устройствами
                    // Modbus.
                    "max_read_registers": 10,

                    // Максимальное время ответа устройства в миллисекундах.
                    // Если не установлено, то принимается равным 500 мс. 
                    // Если значение этого параметра, установленное для порта, больше указанного здесь, используется значение порта.
                    // Этот параметр задан в шаблонах описания устройств, переопределять его можно только в случае некорректной работы с устройством.
                    "response_timeout_ms": 100,

                    // Минимально необходимая задержка между посылками в миллисекундах.
                    // Используется в некоторых протоколах для определения границ посылок.
                    // Этот параметр задан в шаблонах описания устройств, переопределять его можно только в случае некорректной работы с устройством.
                    // По умолчанию 20 мс
                    "frame_timeout_ms": 100,

                    // Дополнительная задержка перед каждой отправкой данных в порт в микросекундах.
                    // Если не установлено, то используется значение, заданное в соответствующем параметре порта.
                    "guard_interval_us": 0,

                    // (При возникновении ошибки) Интервал после последнего успешного обмена данными с устройством,
                    // по истечении которого (а также "device_max_fail_cycles") устройство будет помечено отключенным и будет опрашиваться в ограниченном режиме
                    "device_timeout_ms": 3000,

                    // Количество неудачных циклов опроса устройства
                    // Если в течение указанного количества полных циклов опроса ни по одному регистру устройства не поступило данных (а также истек "device_timeout_ms"),
                    // устройство будет помечено отключенным и будет опрашиваться в ограниченном режиме
                    "device_max_fail_cycles": 2,

                    // пароль для доступа к устройству, массив байт
                    "password": [1, 2, 3],

                    // уровень доступа при опросе устройства,
                    // используется для обмена с счётчиками электроэнергии
                    "access_level": 1,

                    // Параметр, заданный в шаблоне устройства
                    "param1": 10,

                    // список каналов устройства
                    "channels": [
                        {
                            // имя канала, используется в диагностических сообщениях и, 
                            // если не задан параметр id, для формирования названия MQTT topic'ов канала
                            "name" : "Temp 1",

                            // имя MQTT контрола канала. topic'и, соответствующие каналу,
                            // публикуются как /devices/<идентификатор устройства>/controls/<ID канала>
                            // если не задан, то используется значение параметра name
                            "id" : "Temp",

                            // Включает канал в цикл опроса. По умолчанию, равен true.
                            "enabled": true,

                            // тип регистра
                            // возможные значения для Modbus:
                            // "coil" - 1 бит, чтение/запись
                            // "discrete" - 1 бит, только чтение
                            // "holding" - 16 бит, чтение/запись, код функции на запись выбирается автоматически, в зависимости от размера
                            // "input" - 16 бит, только чтение
                            // "holding_single" - то же что и holding однако регистры записываются всегда по одному, кодом 06
                            // "holding_multi" - то же что и holding однако регистры записываются всегда кодом 16
                            "reg_type" : "input",

                            // адрес регистра
                            // Можно читать отдельные биты регистра, для этого запишите адрес в формате: "address":"reg:shift:width", где reg — адрес регистра, shift — смещение от начала, а width — количество считываемых битов. 
                            // Например, "address":"109:1:2" — прочитать второй и третий биты регистра, расположенного по адресу 109.
                            "address" : 0,

                            // тип элемента управления, например,
                            // "temperature", "text", "switch"
                            
                            "type": "temperature",

                            // формат канала. Задаётся для регистров типа
                            // "holding" и "input". Возможные значения:
                            // "u16" - беззнаковое 16-битное целое
                            //         (используется по умолчанию)
                            // "s16" - знаковое 16-битное целое
                            // "u8" - беззнаковое 8-битное целое
                            // "s8" - знаковое 8-битное целое
                            // "u32" - беззнаковое 32-битное целое (big-endian).
                            //     (занимает 2 регистра, начиная с указанного)
                            // "s32" - знаковое 32-битное целое (big-endian).
                            //     (занимает 2 регистра, начиная с указанного)
                            // "s64" - знаковое 64-битное целое (big-endian).
                            //     (занимает 4 регистра, начиная с указанного)
                            // "u64" - беззнаковое 64-битное целое (big-endian).
                            //     (занимает 4 регистра, начиная с указанного)
                            //
                            // "float" - число с плавающей точкой IEEE 754. 32 bit. (big-endian).
                            //     (занимает 2 регистра, начиная с указанного)
                            // "double" - число с плавающей точкой двойной точности IEEE 754. 64 bit. (big-endian).
                            //     (занимает 4 регистра, начиная с указанного)
                            // "char8" - однобайтовый символ в кодировке ASCII
                            // "string" - строка с настраиваемым количествои символов.
                            //            Для протокола modbus cтроки считываются по одному символу на регистр из младшего байта. 

                            "format": "s8",

                            // Порядок 16-битных слов для каналов, имеющих размер больше 16 бит.
                            // Возможные значения:
                            //  "big_endian" (по-умолчанию): [0xAA 0xBB] [0xCC 0xDD] => 0xAABBCCDD
                            //  "little_endian":  [0xAA 0xBB] [0xCC 0xDD] => 0xCCDDAABB
                            "word_order" : "big_endian",

                            // Период чтения данного канала в миллисекундах
                            // Рекомендуется использовать для каналов, данные от которых надо получать с минимальными задержками
                            // Чтение каналов с заданным периодом имеет больший приоритет, чем чтение других каналов
                            // Если не указан, чтение будет производиться в свободное от опроса других каналов время
                            "read_period_ms": 10,

                            // Интервал в миллисекундах, который должен пройти между двумя последовательными чтениями канала.
                            // Учитывается, если не задан параметр "read_period_ms".
                            // Не рекомендуется к использованию, поддерживается для обратной совместимости с ранее созданными конфигурационными файлами.
                            // Вместо него рекомендуется использовать read_period_ms.
                            "read_rate_limit_ms": 10000,

                            // значение, получаемое при последовательном чтении диапазона регистров, если устройство не поддерживает запрашиваемый регистр.
                            // Этот параметр используется некоторыми протоколами, чтобы определить доступность регистров устройства.
                            "unsupported_value": "0xFFFE",

                            // максимальное значение регистра, используется для построения интерфейса веб-конфигуратора
                            "max": 100,

                            // коэффициент, на который умножается значение регистра перед публикацией в MQTT
                            "scale": 0.5,

                            // значение, которое прибавляется к значению регистра перед публикацией в MQTT
                            "offset": -12.5,

                            // порядок, до которого будет округляться значение после всех преобразований
                            "round_to": 0.1,

                            // доступен ли канал для записи через MQTT
                            "readonly": true,

                            // значение, которое будет записано в регистр, при записи единицы в on-топик в MQTT
                            "on_value": "0xFF",

                            // значение, которое будет записано в регистр, при записи нуля в on-топик в MQTT
                            "off_value": "0xAA",

                            // значение регистра, полученное от устройства, которое обозначает ошибку
                            "error_value": "0xAA",

                            // Длина строки в символах. Необходимая опция, если выбран формат "string"
                            "string_data_size": 5
                        },
                        {
                            // Ещё один канал
                            "name" : "Illuminance",
                            "reg_type" : "input",
                            "address" : 1,
                            "type": "text"
                        },
                        {
                            "name" : "Pressure",
                            "reg_type" : "input",
                            "address" : 2,
                            "type": "text",
                            "scale": 0.075
                        },
                        {
                            "name" : "Temp 2",
                            "reg_type" : "input",
                            "address" : 3,
                            "type": "temperature",
                            "format": "s8"
                        }
                    ]
                },
                {
                    // ещё одно устройство на канале
                    "name": "DRB88",
                    "id": "drb88",
                    "enabled": true,
                    "slave_id": 22,

                    // секция инициализации
                    "setup": [
                        {
                            // название регистра
                            // Выводится в случае включённой отладочной печати.
                            "title": "Input 0 type",
                            
                            // адрес регистра
                            "address": 1,
                            
                            // значение для записи
                            "value": 1,

                            // тип регистра, если не указан, то для Modbus используется "holding"
                            "reg_type" : "input",

                            // формат регистра, для Modbus по умолчанию u16
                            "format": "s8"
                        },
                        {
                            "title": "Input 0 module",
                            "address": 3,
                            "value": 3
                        }
                    ],
                    "channels": [
                        {
                            "name" : "Relay 1",
                            "reg_type" : "coil",
                            "address" : 0,
                            "type": "switch"
                        },
                        {
                            "name" : "Relay 2",
                            "reg_type" : "coil",
                            "address" : 1,
                            "type": "switch"
                        },
                        // ...
                        {
                            "name" : "Input 2",
                            "reg_type" : "input",
                            "address" : 1,
                            "type": "switch",
                            "on_value": 101
                        },
                        {
                            "name" : "Input 3",
                            "reg_type" : "input",
                            "address" : 2,
                            "type": "switch",
                            "on_value": 101
                        },
                        // ...
                    ]
                }
            ]
        },
        {
            // ещё один порт со своим набором устройств
            "path" : "/dev/ttyNSC1",
            "baud_rate": 9600,
            "parity": "N",
            "data_bits": 8,
            "stop_bits": 1,
            "enabled": true,
            "devices" : [
                {
                    "name": "tM-P3R3",
                    "id": "tmp3r3",
                    "enabled": true,
                    "slave_id": 1,
                    "channels": [
                        {
                            "name" : "Relay 0",
                            "reg_type" : "coil",
                            "address" : 0,
                            "type": "switch"
                        },
                        // ...
                    ]
                },
                // ...
            ]
        }
    ]
}
```
### Шаблоны конфигурации

Для поддерживаемых устройств существуют шаблоны конфигурации. Для примера в [файле](config.sample.json) приведены разные варианты записи параметров:
- первое устройство задано через шаблон;
- второе устройство тоже через шаблон, но параметры "name" и "id" заданы, и можно добавить конфигурацию для канала, который добавится к тем, что есть в шаблоне;
- параметры третьего устройства записаны явно;
- для четвёртого задано значение одного из параметров. Параметр описан в шаблоне.

Шаблоны описаний устройств при установке пакета расположены в папке `/usr/share/wb-mqtt-serial/templates`. Если необходимо создать шаблон нового устройства, надо сохранить его в папке `/etc/wb-mqtt-serial.conf.d/templates`, она предназначен для пользовательских шаблонов.
Структура папок *templates* такова, что в каждом файле приведены параметры для одного типа устройств.

Пример шаблона:
```jsonc
{
    // Название типа устройства, оно указывается в поле device_type в файле настроек
    "device_type": "Device type name",

    // Название типа устройства, которое будет отображаться в веб-конфигураторе.
    // Необязательный параметр. Если не указан, используется device_type.
    "title": "Device",

    // Признак того, что шаблон устарел, он не будет доступен для выбора при добавлении устройства в веб-конфигураторе
    "deprecated": true,

    "device": {
        // отображаемое имя устройства. Публикуется как
        // .../meta/name в MQTT
        "name": "New device",
        
        // Остальные параметры устройства, описанные выше в примере конфигурационного файла, кроме slave_id
        ...

        // Шаблон может иметь собственную секцию с настройками
        "setup": [
            {
                "title": "s1",
                "address": 20000,
                "value": "0xfff2"
            },
            ...
        ],

        // Секция с описанием параметров устройства.
        // Значение параметра можно задать в файле конфигурации или через веб-конфигуратор
        "parameters": [
            {
                // Имя параметра, которе будет использовано в конфигурационном файле
                "id": "param1",

                // Название параметра в веб-конфигураторе
                "title": "s22",

                // Адрес регистра параметра
                "address": 9992,

                // Тип регистра
                "reg_type" : "input",

                // Формат регистра
                "format": "s8",

                // Список возможных значений
                "enum": [1, 2, 3],

                // Надписи в списке выбора в веб-конфигураторе
                "enum_titles": ["one", "two", "three" ],

                // Значение по умолчанию в веб-конфигураторе
                "default": 2,

                // Минимально возможное значение
                "min": 1,

                // Максимально возможное значение
                "max": 3,

                // Коэффициент, на который делится значение параметра перед записью в регистр
                "scale": 2,

                // Значение, которое прибавляется к значению параметра перед записью в регистр
                "offset": 10,

                // Этот параметр должен быть обязательно задан в wb-mqtt-serial.conf
                "required": true,

                // Порядок отображения параметра в веб-конфигураторе
                "order": 1,

                // Группа, к которой относится параметр
                "group": "group1",

                // Условие, при выполнении которого, значение параметра будет записано в устройство
                // В состав условия могут входить целые числа, названия других параметров, 
                // операции сравнения (>, <, >=, <=, ==, !=) и логические операции (&&, ||).
                // При вычислении условия вместо имён параметров подставляются их значения из конфигурационного файла.
                // Если какой-то параметр из условия не задан в конфигурационном файле, то любое сравнение с ним возвращает false.
                // Условие также определяет доступность параметра для редактирования в интерфейсе веб-конфигуратора
                "condition": "(param2==1)||(param3>5)",

                // Признак того, что значение параметра не записывается в регистры устройства.
                // Может быть использовано для организации настроек в веб-конфигураторе.
                // В зависимости от значения будут отображены только нужные каналы и параметры.
                // В дальнейшем значения таких параметров будет читаться из устройств.
                "readonly": true
            }
        ],

        // Cписок каналов
        "channels": [
            // Пример канала, описывающий данные одного регистра
            {
                "name": "Temperature",
                "reg_type": "input",
                "format": "s32",
                "address": "0x0504",
                "group": "group1",

                // Условие, при выполнении которого, канал будет доступен для опроса
                "condition": "(param2==1)||(param3==5)"
            },
            ...
        ],

        // Группы используются для удобной организации интерфейса веб-конфигуратора
        // и не влияют на структуру конфигурационного файл
        "groups": [
            // Описание группы
            {
                // Уникальное имя группы, отображается в веб-конфигураторе
                "title": "Group 1",

                // Идентификатор группы
                "id": "group1",

                // Позиция группы в списке каналов
                // Если не задана, группа будет расположена перед остальными каналами
                "order": 3,

                // Группа вложена в другую группу
                "group": "group2",

                // Описание группы
                "description": "Group description"
            },
            ...
        ]
    }
}
```
### Перевод названий параметров устройств

Переводы используются в веб-конфигураторе для формирования интерфейса настройки устройств. Они описываются в шаблоне устройства в секции `translations`. Эта секция должен содержать параметры, названные соответственно языку перевода. Они в свою очередь должны содержать параметры, названия которых - оригинальные английские строки, значения - переводы.
Например:
```jsonc
{
    "device_type": "Example",
    "title": "Device",
    "device": {
        "name": "Example device",
        "channels": [
            {
                "name": "Temperature",
                "reg_type": "holding",
                "address": 1,
                "group": "group 1"
            }
        ],
        "parameters": [
            {
                "id": "timeout",
                "title": "Timeout",
                "address": 9992,
                "group": "group 1"
            }
        ],
        "groups": [
            {
                "title": "Group 1",
                "id": "group1",
                "order": 3
            }
        ],
        "translations": {
            "ru": {
                "Device": "Устройство",
                "Temperature": "Температура",
                "Timeout": "Задержка",
                "Group 1": "Группа 1"
            }
        }
    }
}
```
## Особенности работы драйвера
### Таймауты и количество неудачных циклов

Циклом опроса устройства считается внутренний цикл опроса драйвера внутри которого был опрошен хотя бы один из регистров данного устройства.

`connection_timeout_ms` и `connection_max_fail_cycles` - указываются для порта типа TCP или MODBUS TCP. Необходимы для автоматического восстановления соединения. Если в течение `connection_timeout_ms` и более чем `connection_max_fail_cycles` подряд циклов опроса все устройства были отключены, соединение сбрасывается и происходит попытка переподключения. Можно использовать только один тип таймаута, для этого нужно выставить значение 0 другому типу таймаута (например, чтобы осуществлять обнаружение разрыва соединения только по времени, нужно выставить "`connection_max_fail_cycles`": 0). При большом количестве устройств на порту, длительность цикла опроса устройств может сильно варьироваться в зависимости от числа отвечающих устройств, т.к. они вносят дополнительные задержки на ожидание ответа, поэтому если нужно обозначить минимальное количество циклов опроса до отключения вне зависимости от числа устройств, можно использовать вариант `connection_max_fail_cycles`. При использовании только `connection_timeout_ms`, на количество попыток обращения к порту будут влиять другие временные настройки, такие как `poll_interval`, `guard_interval`, `response_timeout` и при их изменении возможно придется подстраивать значение connection_timeout_ms. Если же нужно исключить срабатывание таймаута на каких-то кратковременных случайных ошибках, которые не стоит считать обрывом связи, то нужно использовать `connection_timeout_ms`. При использовании параметров вместе, таймаут сработает только когда выполнятся оба условия, т.е. пройдет нужное время и количество циклов.

`device_timeout_ms` и `device_max_fail_cycles` - указываются для устройства. По семантике аналогичен `connection_timeout_ms` и `connection_max_fail_cycles`, но только для устройства. Нужен для выявления отключения устройства для повторной отправки setup - секции при переподключении. Если в течение `device_timeout_ms` и более чем `device_max_fail_cycles` подряд циклов ни один из опрошенных регистров не был успешно прочитан, то устройство будет помечено как отсоединенное и будет опрашиваться в ограниченном режиме, т.е. при наличии у устройства setup - секции, драйвер будет пытаться записать ее, а в противном случае, будет пытаться опросить устройство. Если первое обращение к устройству в ограниченном режиме закончилось ошибкой, драйвер считает что устройство все еще отключено и больше не опрашивает его в этом цикле. Это позволяет тратить меньше времени на отключенные устройства. Первый успешный запрос к устройству будет расценен как переподключение устройства.

#### Значения по умолчанию
|Параметр                   | Значение  |
|:--------------------------|----------:|
|device_timeout_ms          | 3000      |
|device_max_fail_cycles     | 2         |
|connection_timeout_ms      | 5000      |
|connection_max_fail_cycles | 2         |

#### Замечания для TCP или MODBUS TCP порта

При использовании TCP мостов, драйвер не видит разницы между двумя ситуациями:

- физически отключены все устройства от моста
- разорвано TCP соединение с мостом

так как в обоих случаях никаких данных драйвер не получает. Поэтому, в этом случае, connection_timeout для порта и device_timeout для устройств истекают одновременно.

Это влечет за собой периодический сброс TCP соединения и переподключение к мосту в ситуации когда физически отключены все устройства от моста, хотя с самим TCP соединением проблем нет.

В ситуации когда хотя бы одно из опрашиваемых устройств подключено к мосту без проблем с TCP соединением, TCP подключение не будет сбрасываться, а таймаут будет отсчитываться только для отключенных устройств.

### Диаграмма таймаутов цикла опроса

![Диаграмма таймаутов цикла опроса](doc/timeouts.svg)

### Объединенное чтение регистров и его авто-отключение

Для ускорения опроса регистров устройств, драйвер объединяет чтение соседних регистров в один запрос (см. max_reg_hole, max_bit_hole), однако, считывание т.н. "пустых" регистров может привести к ошибкам на некоторых устройствах. Как только драйвер получает от устройства ошибку при считывании множества регистров, среди которых есть пустые, которая могла быть вызвана чтением пустых регистров (для Modbus: ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE), драйвер перестает объединённо считывать эти регистры.

### Метрики опроса устройств
Метрики можно получить, выполнив MQTT RPC запрос `wb-mqtt-serial/metrics/Load`. Он возвращает JSON массив следующего вида:

```jsonc
[
    {
        // Порт
        "port": "TCP 1.1.1.1:1",

        // Список каналов, опрашиваемых через порт
        "channels": [
            {
                // Список имён каналов в виде пары устройство - контрол, разделённые "/"
                // "Idle" - простой шины
                "names": [ "Device/Channel1", "Device/Channel2", ... ],

                // Процент использования шины данным каналом в последние 1-2 минуты
                "bl": 11.23,

                // Процент использования шины данным каналом в последние 14-15 минут
                "bl15": 3.33,

                // 50% запросов канала в последние 1-2 минуты
                // выполняются с интервалом менее указанного в этом параметре.
                // Значение в мс
                "i50": 100,

                // 95% запросов канала в последние 1-2 минуты
                // выполняются с интервалом менее указанного в этом параметре.
                // Значение в мс
                "i95": 200
            },
            ...
        ]
    },
    ...
]
```

### Прямое чтение и запись в порт
Существует возможность выполнить запись и чтение из порта посредством MQTT RPC запроса. Выполнение запроса встраивается в цикл опроса устройств таким образом, что запрос выполнится с высоким приоритетом сразу после окончания текущего цикла опроса. 
Для упрощенного использования данного функционала написана [Python-библиотека](https://github.com/wirenboard/mqtt-rpc/). Также по [ссылке](https://github.com/wirenboard/modbus-utils-rpc) доступна утилита для работы с modbus-устройствами при помощи RPC-функционала wb-mqtt-serial.
Для выполнения запроса необходимо отправить в топик `wb-mqtt-serial/port/Load/client_id`, где client_id - произвольное имя клиента, посылающего запрос, сообщение типа JSON со следующими параметрами:

#### Обязательные параметры 

|Параметр   |Описание   | 
|--------------|-----------|
|`msg`           | текстовое сообщение для отправки в порт              |
|`response_size` | количество байт, которое нужно прочитать из порта    |

##### Параметры запроса в последовательный порт
|Параметр   |Описание   | 
|------|-----------|
|`path`  | путь к последовательному порту, в который будет отправлено сообщение      |

##### Параметры запроса в TCP порт
|Параметр   |Описание   | 
|------|-----------|
|`ip`    | IP-адрес клиента, которому будет отправлено сообщение |
|`port`  | номер порта на указанном адресе клиента               |

#### Необязательные параметры

|Параметр                  |Значение по умолчанию | Описание   | 
|--------------------------|----------------------|------------|
|`format`                    |`STR`    | при указании значения `STR` содержимое параметра `msg` интерпретируется как строка и передается в порт как есть. При указании значения `HEX` содержимое `msg` интерпретируется как шестнадцатеричная строка и перед отправкой в порт преобразуется в массив байт
|`response_timeout`          |500 ms | таймаут чтения первого байта в миллисекундах
|`frame_timeout`             |20 ms | таймаут чтения каждого последующего байта в миллисекундах
|`total_timeout`             |10000ms  | таймаут выполнения RPC-запроса в миллисекундах

В качестве ответа в топике `wb-mqtt-serial/port/Load/client_id/reply` будет опубликовано сообщение типа JSON со следующими параметрами:

|Параметр | Описание|
|---------|---------|
|`result`|В случае неуспешного выполнения запроса содержит `null`. В случае успешного выполнения содержит в себе единственное поле `response`. В случае, если при запросе в поле `format` было указано `STR`, значение поля представляет собой набор символов, полученных из порта, и передается запрашивающей стороне как есть. В случае значения `HEX` содержимое поля представляет собой шестнадцатеричную строку
|`id`| Порядковый номер запроса|
|`error`|В случае успешного выполнения запроса содержит значение `null`. В ином случае содержит параметры, приведенные в таблице ниже

|Параметр|Описание|
|--------|--------|
|`message`|Строка с кратким описанием ошибки|
|`code`| Код ошибки. Возможные коды ошибок приведены в таблице ниже|
|`data`| Строка с подробным описанием места и условий возникновения ошибки|

|Код ошибки|Описание|
|----------|--------|
|`-32700`|Ошибка разбора JSON запроса|
|`-32000`|Ошибка выполнения запроса|
|`-32100`|Таймаут выполнения запроса|

Примеры выполнения запросов:
1. Успешное выполнение запроса:
    ```
    RPC Client -> {'response_size': 8, 'format': 'HEX', 'path': '/dev/ttyRS485-2', 'msg': '1605000aff00af1f', 'total_timeout': 10000}
    RPC Client <- {"error":null,"id":1,"result":{"response":"1605000aff00af1f"}}
    ```
   
2. Ошибка разбора JSON запроса
    ```
    RPC Client -> {"params""path": "/dev/ttyRS485-34534", "response_size": 8, "total_timeout": 10000, "msg": "1605000aff00af1f", "format": "HEX"}, "id": 1}
    RPC Client <-{"error":{"code":-32700,"message":"Parse error"},"id":null}
    ```

3. Ошибка выполнения запроса (ошибка ввода-вывода)
    ```
    RPC Client -> {'msg': '1605000aff00af1f', 'total_timeout': 10000, 'path': '/dev/ttyRS485-2', 'format': 'HEX', 'response_size': 8}
    RPC Client <- {"error":{"code":-32000,"data":"Port IO error","message":"Server error"},"id":1,"result":null}
    ```

4. Ошибка выполнения запроса (запрос в несуществующий порт)
    ```
    RPC Client -> {'path': '/dev/ttyRS485-34534', 'response_size': 8, 'total_timeout': 10000, 'msg': '1605000aff00af1f', 'format': 'HEX'}
    RPC Client -> {"error":{"code":-32000,"data":"Requested port doesn't exist","message":"Server error"},"id":1,"result":null}
    ```

5. Таймаут выполнения запроса (слишком малое значение таймаута)
    ```
    RPC Client -> {'msg': '1605000aff00af1f', 'path': '/dev/ttyRS485-2', 'total_timeout': 10, 'format': 'HEX', 'response_size': 8}
    RPC Client <- {"error":{"code":-32600,"data":"Request handler is not responding @ src/rpc_handler.cpp:179","message":"Request timeout"},"id":1,"result":null}
    ```

## Протоколы

### Поддержка различных протоколов на одной шине

Возможно использование устройств, работающих по различным протоколам, на одном порту. При этом следует учитывать особенности конкретных протоколов.  

Например, фреймы устройств Uniel начинаются с байта 0xff, устройств ИВТМ - с байта 0x24 ('$'), в случае же протоколов Modbus, Меркурий 230 и Милур первым байтом фрейма является идентификатор slave, поэтому при совмещении подобных устройств следует внимательно подходить к выбору slave id - у устройств Милур, например, slave id по умолчанию равен 0xff, что приводит к конфликту с устройствами Uniel. 

Устройства Милур требуют дополнительных задержек при опросе (заданы в шаблоне) и при использовании на одной шине с другими устройствами могут снизить скорость опроса. 

Некоторые устройства, поддерживающие дополнительные протоколы, могут оказаться несовместимыми с теми или иными протоколами на той же шине, например, было замечено, что устройства с поддержкой протокола A-BUS производства "Разумный дом" не могут работать на одной шине с устройствами Uniel. 

Работа устройств ИВТМ на одной шине с устройствами, работающими по другим протоколам, не проверялась. Проверенная рабочая комбинация: Modbus + Milur (slave_id != 0xff) + Uniel на одной шине.

### Широковещательные сообщения
Протоколы `Меркурий 230`, `Энергомера ГОСТ МЭК 61107`,
`НЕВА МТ 32х ГОСТ МЭК 61107` поддерживают отправку широковещательных сообщений, если не указывать идентификатор устройства, или указать вместо него пустую строку. Это можно использовать, если на шине только одно устройство такого типа, и его адрес неизвестен. При этом нельзя на одном порту одновременно использовать широковещательные сообщения `Энергомера ГОСТ МЭК 61107` и `НЕВА МТ 32х ГОСТ МЭК 61107`.

### Энергомера ГОСТ МЭК 61107

Протокол работает только со следующими настройками порта: 9600 8N1 или 9600 7E1. При выборе 9600 8N1 физически обмен с счётчиками происходит в режиме 9600 7E1, в соответствии с МЭК 61107, но бит чётности эмулируется программно за счёт восьмого бита посылки. Это сделано для возможности использования счётчиков на одной шине с другими устройствами, которые работают только с восьмибитными словами.

Реализованы 2 режима обмена:
- "быстрого группового чтения" без открытия сессии (`"device_type": "energomera_iec"`);
- ГОСТ МЭК 61107 Mode C (`"device_type": "energomera_iec_mode_c"`).

Режим "быстрого группового чтения" специфичен для протокола счётчиков Энергомера и не соответствует стандарту ГОСТ МЭК 61107. Список параметров, доступных для чтения, приведён в Таблице 11 [руководства пользователя счётчиков CE301/303](http://www.energomera.ru/documentations/product/ce301_303_rp.pdf). Поддерживаются только параметры с пустым запросом и с запросом-битовой маской.

Параметры кодируются в адресе регистра как `0xAABBCC`, где `AA` - "тип" параметра, `BB` - "уточнение", `СС` - номер бита из битовой маски запроса.

Режим ГОСТ МЭК 61107 Mode C соответствует стандарту, список параметров, доступных для чтения, можно найти в руководствах конкретных счётчиков. Параметры кодируются в адресе регистра строкой, она должна содержать полный запрос, включая `(` и `)`. Например, суммарные показания энергии для счётчика Энергомера СЕ102М будут иметь адрес `ET0PE(1)`.

### НЕВА МТ 32х ГОСТ МЭК 61107

Протокол работает только со следующими настройками порта: 9600 8N1 или 9600 7E1. При выборе 9600 8N1 физически обмен с счётчиками происходит в режиме 9600 7E1, в соответствии с МЭК 61107, но бит чётности эмулируется программно за счёт восьмого бита посылки. Это сделано для возможности использования счётчиков на одной шине с другими устройствами, которые работают только с восьмибитными словами.

Реализован режим чтения параметров по OBIS-кодам ([IEC 62056-6-1:2017](https://en.wikipedia.org/wiki/IEC_62056)) 

OBIS-коды кодируются в адресе регистра следующим образом:
    
    0xCCDDEEFF

где `CC` - группа С, `DD` - группа D, `EE` - группа E, `FF` - группа F OBIS-кода.

### DLMS/COSEM и СПОДЭС

Физический адрес устройства задаётся в параметре `slave_id`. Опрашивается логическое устройство с адресом 1.
Адрес клиента задаётся в параметре `dlms_client_address`, если он не задан, используется адрес 16 (публичный клиент).
Тип аутентификации задаётся в параметре `dlms_auth`.

Коммуникационный профиль задаётся в параметре `dlms_interface`, если он не задан, используется протокол HDLC. Поддерживается адресация по логическому имени объектов.

Данные читаются по OBIS-кодам ([IEC 62056-6-1:2017](https://en.wikipedia.org/wiki/IEC_62056)). OBIS-коды записываются в адресе регистра строкой, например `0.0.96.9.0.255`. Поддерживается автоматический разбор данных от объектов с классом `register`(class_id = 3), остальные классы не поддерживаются.

Реализован анализ доступных объектов устройства и генерация шаблона. Для этого надо остановить `wb-mqtt-serial` и запустить его из командной строки с параметром `-G`. Сгенерированный шаблон будет записан в каталог `/etc/wb-mqtt-serial.conf.d/templates`.

Пример команд для генерации шаблона:
```bash
# systemctl stop wb-mqtt-serial
# wb-mqtt-serial -G 2,/dev/ttyMOD3,9600-8-N-1,dlms_hdlc:32,32,1,12345678
# systemctl start wb-mqtt-serial
```
Подробнее об опциях параметра `-G` можно узнать во встроенной справке `wb-mqtt-serial -G help`.

### Somfy SDN

Тип мотора(`node type`) можно задать через параметр устройства `node_type`. По умолчанию используется Sonesse 30.
Для организации отправки команд можно использовать канал с типом регистра `command`. 

В этом случае заголовок пакета (`MSG`) задаётся в адресе регистра. Число, записываемое в такой регистр должны содержать длину в младшем байте. Например, `0x03020103` будет означать, что в команду будет добавлено 3 байта: 0x01, 0x02, 0x03.

Для организации запроса статуса можно использовать канал с типом регистра `param`. В этом случае заголовок запроса (`MSG`) задаётся в адресе регистра. А заголовок ответа - в параметре `response_header`. Поддерживается возможность указать смещение и длину данных в ответе.

### WinDeco

Для организации отправки команд можно использовать канал с типом регистра `command`. В этом случае код команды задаётся в адресе регистра.

### Dooya

Для организации отправки команд управления можно использовать канал с типом регистра `command`.
Для организации доступа к настройкам можно использовать канал с типом регистра `param`.
Во всех случаях адрес данных задаётся в адресе регистра.

### Меркурий 200

Типы регистров:
- param8 - восьмибитное число
- param16 - 16-тибитное число
- param24 - 24-тибитное число
- param32 - 32-тибитное число

Код команды задаётся в адресе регистра, при этом младший байт задаёт смещение данных в ответе.

### Таблица шаблонов device_type

Сгруппирована по протоколам.

**Modbus-RTU**

|                          Device                         | device_type | id_prefix  | name_prefix   |
|:-------------------------------------------------------:|:-----------:|:----------:|:-------------:|
| "Разумный дом" четырёхканальный диммер светодиодов DDL4 |    DDL24    |   ddl24    |    DDL24      |
|           "Разумный дом" релейный модуль DRB88          |    DRB88    |   drb88    |    DRB88      |
|           RD DDL04R LED Strip Dimmer                    |    DDL04R   |   ddl04r   |    DDL04R     |
|      "ICP DAS" модуль управления освещением LC-103      |    LC-103   |   lc-103   |    LC-103     |
|                   "Разумный дом" MSU24                  |    MSU24    |   msu24    |    MSU24      |
|                   "Разумный дом" MSU21                  |    MSU21    |   msu21    |    MSU21      |
|                   "Разумный дом" MSU34+TLP              |    MSU34    |   msu34tlp |  MSU34+TLP    |
|                   "Разумный дом" MSU34+TLHP             | MSU34TLHP   | msu34tlhp  |  MSU34+TLHP   |
|          "ICP DAS" модуль ввода-вывода TM-P3R3          |   TM-P3R3   |  TM-P3R3   |    tmp3r3     |
|     "Kvadro" модуль подключения термометров 1-wire      |kvadro-1wire |kvadro-1wire| Kvadro 1-Wire |
|     PD561Z-9SY счётчик электроэнергии                   |    PD561Z   |  pd561z    | pd561z        |
|     SDM220 счётчик электроэнергии                       |    SDM220   |  sdm220    |  sdm220       |
|     SDM120 счётчик электроэнергии                       |    SDM120   |  sdm120    |  sdm120       |
|     WELLPRO WP8028ADAM (8DI/8DO)                        | WP8028ADAM  | wp8028adam |   WP8028ADAM  |
|  Wiren Board RGB-диммер WB-MRGB                         |   WB-MRGB   |  WB-MRGB   |   wb-mrgb     |
|  Wiren Board Релейный модуль WB-MRM2                    |   WB-MRM2   |  WB-MRM2   |   wb-mrm2     |
|  Wiren Board Релейный модуль WB-MR11                    |   WB-MR11   |  WB-MR11   |   wb-mr11     |
|  Wiren Board Релейный модуль WB-MR14                    |   WB-MR14   |  WB-MR14   |   wb-mr14     |
|  Wiren Board модуль дискретных/счётных входов WB-MCM16  |   WB-MCM16  |  WB-MCM16  |   wb-mcm16    |
|  Wiren Board Датчик WB-MS-THLS / WB-MSW-THLS            |  WB-MS-THLS | wb-ms-thls | WB-MS-THLS    |
|  Wiren Board Датчик WB-MS-THLS / WB-MSW-THLS  (fw. v.2) |  WB-MS-THLS v.2 | wb-ms-thls | WB-MS-THLS    |
|  Peacefair PZEM-016                                     |  PZEM-016   | pzem       | PZEM          |   

**Милур**
|                     Device                     | device_type   | id_prefix | name_prefix      |
|:----------------------------------------------:|:-------------:|:---------:|:----------------:|
| Счётчик электроэнергии Милур-305               | milur305      | milur305  | Milur 305        |
| Счётчик электроэнергии Милур-105 (Милур-104)   | Milur 104/105 | milur105  | Milur 105        |

**Mercury 230**
|                     Device                     | device_type | id_prefix      | name_prefix      |
|:----------------------------------------------:|:-----------:|:--------------:|:----------------:|
| Счётчик электроэнергии Меркурий-230            | mercury230  | mercury230ar02 | Mercury 230AR-02 |

**Uniel**
|                     Device                     | device_type | id_prefix      | name_prefix      |
|:----------------------------------------------:|:-----------:|:--------------:|:----------------:|
| Модуль управления освещением UCH-M111RX        | UCH-M111RX  | uchm111rx      | UCH-M111RX 0808  |
| Модуль управления автоматикой UCH-M121RX       | UCH-M121RX  | uchm121rx      | UCH-M121RX 0808  |
| Диммер светодиодных ламп UCH-M141RC            | UCH-M141RC  | uchm141rc      | UCH-M141RC 0808  |


**ИВТМ**
|                     Device                     | device_type | id_prefix      | name_prefix      |
|:----------------------------------------------:|:-----------:|:--------------:|:----------------:|
| Термогигрометр ИВТМ-7 М 3                      | IVTM-7M-3   | ivtm7m3        | IVTM-7M-3        |

**Пульсар**
|                     Device                     | device_type    | id_prefix      | name_prefix           |
|:----------------------------------------------:|:--------------:|:--------------:|:---------------------:|
| Счётчик воды "Пульсар"                         | pulsar-water   | pulsar-water   |  Pulsar Water Meter   |
| Счётчик воды многоструйный "Пульсар-М"         | pulsar-m-water | pulsar-m-water |  Pulsar-M Water Meter |
| Счётчик тепла "Пульсар"                        | pulsar-heat    | pulsar-heat    |  Pulsar Heat Meter    |

**Энергомера МЭК 61107**
|                     Device                     | device_type    | id_prefix      | name_prefix           |
|:----------------------------------------------:|:--------------:|:--------------:|:---------------------:|
| Энергомера CE301 счётчик активной электрической энергии трёхфазный                         | Energomera CE301/CE303   | energomera301   |  Energomera CE301   |
| Энергомера CE303 счётчик активной и реактивной электрической энергии трёхфазный                         | Energomera CE303   | energomera303   |  Energomera CE303   |

**НЕВА МТ 323/324**
|                       Device                     | device_type   | id_prefix      | name_prefix   |
|:------------------------------------------------:|:-------------:|:--------------:|:-------------:|
| НЕВА МТ 323/324 трёхфазный многотарифный счётчик | NEVA MT 32x   | neva32x        |  NEVA MT 32x  |

**DLMS/COSEM, СПОДЭС**
|                     Device                     | device_type    | id_prefix      | name_prefix           |
|:----------------------------------------------:|:--------------:|:--------------:|:---------------------:|
| Энергомера CE308 Z счетчик электроэнергии трехфазный многофункциональный | energomera_ce308_dlms   | energomera308   |  Energomera CE308   |
| Счётчик электроэнергии Меркурий 234 D          | mercury_234_dlms   | mercury234   |  Mercury 234   |

**Somfy SDN**
|                     Device                     | device_type    | id_prefix      | name_prefix           |
|:----------------------------------------------:|:--------------:|:--------------:|:---------------------:|
| Мотор управления шторами Somfy SDN             | Somfy SDN      | somfy          |  Somfy SDN            |

**WinDeco**
|                     Device                     | device_type    | id_prefix      | name_prefix           |
|:----------------------------------------------:|:--------------:|:--------------:|:---------------------:|
| Мотор управления шторами WinDeco               | WinDeco        | windeco        |  WinDeco              |

**Dooya**
|                     Device                     | device_type    | id_prefix      | name_prefix           |
|:----------------------------------------------:|:--------------:|:--------------:|:---------------------:|
| Мотор управления шторами Dooya DT82            | Dooya 82       | dooya          |  Dooya 82             |
| Мотор управления шторами Akko AM82             | Dooya 82       | dooya          |  Dooya 82             |
